# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2000-2020 Kitware, Inc. and Contributors
# This file is distributed under the same license as the CMake package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMake 3.19\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-04 18:17+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko_KR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../guide/tutorial/index.rst:2
msgid "CMake Tutorial"
msgstr ""

#: ../../../guide/tutorial/index.rst:5
msgid "Contents"
msgstr ""

#: ../../../guide/tutorial/index.rst:9
msgid "Introduction"
msgstr ""

#: ../../../guide/tutorial/index.rst:11
msgid ""
"The CMake tutorial provides a step-by-step guide that covers common build "
"system issues that CMake helps address. Seeing how various topics all work "
"together in an example project can be very helpful. The tutorial "
"documentation and source code for examples can be found in the ``Help/guide/"
"tutorial`` directory of the CMake source code tree. Each step has its own "
"subdirectory containing code that may be used as a starting point. The "
"tutorial examples are progressive so that each step provides the complete "
"solution for the previous step."
msgstr ""

#: ../../../guide/tutorial/index.rst:21
msgid "A Basic Starting Point (Step 1)"
msgstr ""

#: ../../../guide/tutorial/index.rst:23
msgid ""
"The most basic project is an executable built from source code files. For "
"simple projects, a three line ``CMakeLists.txt`` file is all that is "
"required. This will be the starting point for our tutorial. Create a "
"``CMakeLists.txt`` file in the ``Step1`` directory that looks like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:28
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name\n"
"project(Tutorial)\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)"
msgstr ""

#: ../../../guide/tutorial/index.rst:39
msgid ""
"Note that this example uses lower case commands in the ``CMakeLists.txt`` "
"file. Upper, lower, and mixed case commands are supported by CMake. The "
"source code for ``tutorial.cxx`` is provided in the ``Step1`` directory and "
"can be used to compute the square root of a number."
msgstr ""

#: ../../../guide/tutorial/index.rst:45
msgid "Adding a Version Number and Configured Header File"
msgstr ""

#: ../../../guide/tutorial/index.rst:47
msgid ""
"The first feature we will add is to provide our executable and project with "
"a version number. While we could do this exclusively in the source code, "
"using ``CMakeLists.txt`` provides more flexibility."
msgstr ""

#: ../../../guide/tutorial/index.rst:51
msgid ""
"First, modify the ``CMakeLists.txt`` file to use the :command:`project` "
"command to set the project name and version number."
msgstr ""

#: ../../../guide/tutorial/index.rst:54
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name and version\n"
"project(Tutorial VERSION 1.0)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:58
msgid ""
"Then, configure a header file to pass the version number to the source code:"
msgstr ""

#: ../../../guide/tutorial/index.rst:61
msgid ""
"configure_file(TutorialConfig.h.in TutorialConfig.h)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:66
msgid ""
"Since the configured file will be written into the binary tree, we must add "
"that directory to the list of paths to search for include files. Add the "
"following lines to the end of the ``CMakeLists.txt`` file:"
msgstr ""

#: ../../../guide/tutorial/index.rst:70 ../../../guide/tutorial/index.rst:311
msgid ""
"target_include_directories(Tutorial PUBLIC\n"
"                           \"${PROJECT_BINARY_DIR}\"\n"
"                           )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:74
msgid ""
"Using your favorite editor, create ``TutorialConfig.h.in`` in the source "
"directory with the following contents:"
msgstr ""

#: ../../../guide/tutorial/index.rst:77
msgid ""
"// the configured options and settings for Tutorial\n"
"#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@\n"
"#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:80
msgid ""
"When CMake configures this header file the values for "
"``@Tutorial_VERSION_MAJOR@`` and ``@Tutorial_VERSION_MINOR@`` will be "
"replaced."
msgstr ""

#: ../../../guide/tutorial/index.rst:84
msgid ""
"Next modify ``tutorial.cxx`` to include the configured header file, "
"``TutorialConfig.h``."
msgstr ""

#: ../../../guide/tutorial/index.rst:87
msgid ""
"Finally, let's print out the executable name and version number by updating "
"``tutorial.cxx`` as follows:"
msgstr ""

#: ../../../guide/tutorial/index.rst:90
msgid ""
"  if (argc < 2) {\n"
"    // report version\n"
"    std::cout << argv[0] << \" Version \" << Tutorial_VERSION_MAJOR << \"."
"\"\n"
"              << Tutorial_VERSION_MINOR << std::endl;\n"
"    std::cout << \"Usage: \" << argv[0] << \" number\" << std::endl;\n"
"    return 1;\n"
"  }\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:96
msgid "Specify the C++ Standard"
msgstr ""

#: ../../../guide/tutorial/index.rst:98
msgid ""
"Next let's add some C++11 features to our project by replacing ``atof`` with "
"``std::stod`` in ``tutorial.cxx``.  At the same time, remove ``#include "
"<cstdlib>``."
msgstr ""

#: ../../../guide/tutorial/index.rst:102
msgid ""
"  const double inputValue = std::stod(argv[1]);\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:107
msgid ""
"We will need to explicitly state in the CMake code that it should use the "
"correct flags. The easiest way to enable support for a specific C++ standard "
"in CMake is by using the :variable:`CMAKE_CXX_STANDARD` variable. For this "
"tutorial, set the :variable:`CMAKE_CXX_STANDARD` variable in the "
"``CMakeLists.txt`` file to 11 and :variable:`CMAKE_CXX_STANDARD_REQUIRED` to "
"True. Make sure to add the ``CMAKE_CXX_STANDARD`` declarations above the "
"call to ``add_executable``."
msgstr ""

#: ../../../guide/tutorial/index.rst:115
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name and version\n"
"project(Tutorial VERSION 1.0)\n"
"\n"
"# specify the C++ standard\n"
"set(CMAKE_CXX_STANDARD 11)\n"
"set(CMAKE_CXX_STANDARD_REQUIRED True)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:120
msgid "Build and Test"
msgstr ""

#: ../../../guide/tutorial/index.rst:122
msgid ""
"Run the :manual:`cmake <cmake(1)>` executable or the :manual:`cmake-gui "
"<cmake-gui(1)>` to configure the project and then build it with your chosen "
"build tool."
msgstr ""

#: ../../../guide/tutorial/index.rst:126
msgid ""
"For example, from the command line we could navigate to the ``Help/guide/"
"tutorial`` directory of the CMake source code tree and create a build "
"directory:"
msgstr ""

#: ../../../guide/tutorial/index.rst:130
msgid "mkdir Step1_build"
msgstr ""

#: ../../../guide/tutorial/index.rst:134
msgid ""
"Next, navigate to the build directory and run CMake to configure the project "
"and generate a native build system:"
msgstr ""

#: ../../../guide/tutorial/index.rst:137
msgid ""
"cd Step1_build\n"
"cmake ../Step1"
msgstr ""

#: ../../../guide/tutorial/index.rst:142
msgid "Then call that build system to actually compile/link the project:"
msgstr ""

#: ../../../guide/tutorial/index.rst:144
msgid "cmake --build ."
msgstr ""

#: ../../../guide/tutorial/index.rst:148
msgid "Finally, try to use the newly built ``Tutorial`` with these commands:"
msgstr ""

#: ../../../guide/tutorial/index.rst:150
msgid ""
"Tutorial 4294967296\n"
"Tutorial 10\n"
"Tutorial"
msgstr ""

#: ../../../guide/tutorial/index.rst:157
msgid "Adding a Library (Step 2)"
msgstr ""

#: ../../../guide/tutorial/index.rst:159
msgid ""
"Now we will add a library to our project. This library will contain our own "
"implementation for computing the square root of a number. The executable can "
"then use this library instead of the standard square root function provided "
"by the compiler."
msgstr ""

#: ../../../guide/tutorial/index.rst:164
msgid ""
"For this tutorial we will put the library into a subdirectory called "
"``MathFunctions``. This directory already contains a header file, "
"``MathFunctions.h``, and a source file ``mysqrt.cxx``. The source file has "
"one function called ``mysqrt`` that provides similar functionality to the "
"compiler's ``sqrt`` function."
msgstr ""

#: ../../../guide/tutorial/index.rst:170
msgid ""
"Add the following one line ``CMakeLists.txt`` file to the ``MathFunctions`` "
"directory:"
msgstr ""

#: ../../../guide/tutorial/index.rst:173
msgid "add_library(MathFunctions mysqrt.cxx)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:176
msgid ""
"To make use of the new library we will add an :command:`add_subdirectory` "
"call in the top-level ``CMakeLists.txt`` file so that the library will get "
"built. We add the new library to the executable, and add ``MathFunctions`` "
"as an include directory so that the ``mqsqrt.h`` header file can be found. "
"The last few lines of the top-level ``CMakeLists.txt`` file should now look "
"like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:182
msgid ""
"# add the MathFunctions library\n"
"add_subdirectory(MathFunctions)\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)\n"
"\n"
"target_link_libraries(Tutorial PUBLIC MathFunctions)\n"
"\n"
"# add the binary tree to the search path for include files\n"
"# so that we will find TutorialConfig.h\n"
"target_include_directories(Tutorial PUBLIC\n"
"                          \"${PROJECT_BINARY_DIR}\"\n"
"                          \"${PROJECT_SOURCE_DIR}/MathFunctions\"\n"
"                          )"
msgstr ""

#: ../../../guide/tutorial/index.rst:199
msgid ""
"Now let us make the MathFunctions library optional. While for the tutorial "
"there really isn't any need to do so, for larger projects this is a common "
"occurrence. The first step is to add an option to the top-level ``CMakeLists."
"txt`` file."
msgstr ""

#: ../../../guide/tutorial/index.rst:204
msgid ""
"option(USE_MYMATH \"Use tutorial provided math implementation\" ON)\n"
"\n"
"# configure a header file to pass some of the CMake settings\n"
"# to the source code\n"
"configure_file(TutorialConfig.h.in TutorialConfig.h)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:209
msgid ""
"This option will be displayed in the :manual:`cmake-gui <cmake-gui(1)>` and :"
"manual:`ccmake <ccmake(1)>` with a default value of ON that can be changed "
"by the user. This setting will be stored in the cache so that the user does "
"not need to set the value each time they run CMake on a build directory."
msgstr ""

#: ../../../guide/tutorial/index.rst:215
msgid ""
"The next change is to make building and linking the MathFunctions library "
"conditional. To do this we change the end of the top-level ``CMakeLists."
"txt`` file to look like the following:"
msgstr ""

#: ../../../guide/tutorial/index.rst:219
msgid ""
"if(USE_MYMATH)\n"
"  add_subdirectory(MathFunctions)\n"
"  list(APPEND EXTRA_LIBS MathFunctions)\n"
"  list(APPEND EXTRA_INCLUDES \"${PROJECT_SOURCE_DIR}/MathFunctions\")\n"
"endif()\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)\n"
"\n"
"target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})\n"
"\n"
"# add the binary tree to the search path for include files\n"
"# so that we will find TutorialConfig.h\n"
"target_include_directories(Tutorial PUBLIC\n"
"                           \"${PROJECT_BINARY_DIR}\"\n"
"                           ${EXTRA_INCLUDES}\n"
"                           )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:223
msgid ""
"Note the use of the variable ``EXTRA_LIBS`` to collect up any optional "
"libraries to later be linked into the executable. The variable "
"``EXTRA_INCLUDES`` is used similarly for optional header files. This is a "
"classic approach when dealing with many optional components, we will cover "
"the modern approach in the next step."
msgstr ""

#: ../../../guide/tutorial/index.rst:229
msgid ""
"The corresponding changes to the source code are fairly straightforward. "
"First, in ``tutorial.cxx``, include the ``MathFunctions.h`` header if we "
"need it:"
msgstr ""

#: ../../../guide/tutorial/index.rst:233
msgid ""
"#ifdef USE_MYMATH\n"
"#  include \"MathFunctions.h\"\n"
"#endif\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:238
msgid ""
"Then, in the same file, make ``USE_MYMATH`` control which square root "
"function is used:"
msgstr ""

#: ../../../guide/tutorial/index.rst:241
msgid ""
"#ifdef USE_MYMATH\n"
"  const double outputValue = mysqrt(inputValue);\n"
"#else\n"
"  const double outputValue = sqrt(inputValue);\n"
"#endif\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:246
msgid ""
"Since the source code now requires ``USE_MYMATH`` we can add it to "
"``TutorialConfig.h.in`` with the following line:"
msgstr ""

#: ../../../guide/tutorial/index.rst:249
msgid "#cmakedefine USE_MYMATH\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:253
msgid ""
"**Exercise**: Why is it important that we configure ``TutorialConfig.h.in`` "
"after the option for ``USE_MYMATH``? What would happen if we inverted the "
"two?"
msgstr ""

#: ../../../guide/tutorial/index.rst:256
msgid ""
"Run the :manual:`cmake  <cmake(1)>` executable or the :manual:`cmake-gui "
"<cmake-gui(1)>` to configure the project and then build it with your chosen "
"build tool. Then run the built Tutorial executable."
msgstr ""

#: ../../../guide/tutorial/index.rst:260
msgid ""
"Now let's update the value of ``USE_MYMATH``. The easiest way is to use the :"
"manual:`cmake-gui <cmake-gui(1)>` or  :manual:`ccmake <ccmake(1)>` if you're "
"in the terminal. Or, alternatively, if you want to change the option from "
"the command-line, try:"
msgstr ""

#: ../../../guide/tutorial/index.rst:265
msgid "cmake ../Step2 -DUSE_MYMATH=OFF"
msgstr ""

#: ../../../guide/tutorial/index.rst:269
msgid "Rebuild and run the tutorial again."
msgstr ""

#: ../../../guide/tutorial/index.rst:271
msgid "Which function gives better results, sqrt or mysqrt?"
msgstr ""

#: ../../../guide/tutorial/index.rst:274
msgid "Adding Usage Requirements for Library (Step 3)"
msgstr ""

#: ../../../guide/tutorial/index.rst:276
msgid ""
"Usage requirements allow for far better control over a library or "
"executable's link and include line while also giving more control over the "
"transitive property of targets inside CMake. The primary commands that "
"leverage usage requirements are:"
msgstr ""

#: ../../../guide/tutorial/index.rst:281
msgid ":command:`target_compile_definitions`"
msgstr ""

#: ../../../guide/tutorial/index.rst:282
msgid ":command:`target_compile_options`"
msgstr ""

#: ../../../guide/tutorial/index.rst:283
msgid ":command:`target_include_directories`"
msgstr ""

#: ../../../guide/tutorial/index.rst:284
msgid ":command:`target_link_libraries`"
msgstr ""

#: ../../../guide/tutorial/index.rst:286
msgid ""
"Let's refactor our code from `Adding a Library (Step 2)`_ to use the modern "
"CMake approach of usage requirements. We first state that anybody linking to "
"MathFunctions needs to include the current source directory, while "
"MathFunctions itself doesn't. So this can become an ``INTERFACE`` usage "
"requirement."
msgstr ""

#: ../../../guide/tutorial/index.rst:292
msgid ""
"Remember ``INTERFACE`` means things that consumers require but the producer "
"doesn't. Add the following lines to the end of ``MathFunctions/CMakeLists."
"txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:296
msgid ""
"target_include_directories(MathFunctions\n"
"          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"          )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:300
msgid ""
"Now that we've specified usage requirements for MathFunctions we can safely "
"remove our uses of the ``EXTRA_INCLUDES`` variable from the top-level "
"``CMakeLists.txt``, here:"
msgstr ""

#: ../../../guide/tutorial/index.rst:304
msgid ""
"if(USE_MYMATH)\n"
"  add_subdirectory(MathFunctions)\n"
"  list(APPEND EXTRA_LIBS MathFunctions)\n"
"endif()\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:309
msgid "And here:"
msgstr ""

#: ../../../guide/tutorial/index.rst:315
msgid ""
"Once this is done, run the :manual:`cmake  <cmake(1)>` executable or the :"
"manual:`cmake-gui <cmake-gui(1)>` to configure the project and then build it "
"with your chosen build tool or by using ``cmake --build .`` from the build "
"directory."
msgstr ""

#: ../../../guide/tutorial/index.rst:321
msgid "Installing and Testing (Step 4)"
msgstr ""

#: ../../../guide/tutorial/index.rst:323
msgid ""
"Now we can start adding install rules and testing support to our project."
msgstr ""

#: ../../../guide/tutorial/index.rst:326
msgid "Install Rules"
msgstr ""

#: ../../../guide/tutorial/index.rst:328
msgid ""
"The install rules are fairly simple: for MathFunctions we want to install "
"the library and header file and for the application we want to install the "
"executable and configured header."
msgstr ""

#: ../../../guide/tutorial/index.rst:332
msgid "So to the end of ``MathFunctions/CMakeLists.txt`` we add:"
msgstr ""

#: ../../../guide/tutorial/index.rst:334
msgid ""
"install(TARGETS MathFunctions DESTINATION lib)\n"
"install(FILES MathFunctions.h DESTINATION include)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:338
msgid "And to the end of the top-level ``CMakeLists.txt`` we add:"
msgstr ""

#: ../../../guide/tutorial/index.rst:340
msgid ""
"install(TARGETS Tutorial DESTINATION bin)\n"
"install(FILES \"${PROJECT_BINARY_DIR}/TutorialConfig.h\"\n"
"  DESTINATION include\n"
"  )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:345
msgid ""
"That is all that is needed to create a basic local install of the tutorial."
msgstr ""

#: ../../../guide/tutorial/index.rst:347
msgid ""
"Now run the :manual:`cmake  <cmake(1)>` executable or the :manual:`cmake-gui "
"<cmake-gui(1)>` to configure the project and then build it with your chosen "
"build tool."
msgstr ""

#: ../../../guide/tutorial/index.rst:351
msgid ""
"Then run the install step by using the ``install`` option of the :manual:"
"`cmake  <cmake(1)>` command (introduced in 3.15, older versions of CMake "
"must use ``make install``) from the command line. For multi-configuration "
"tools, don't forget to use the ``--config`` argument to specify the "
"configuration. If using an IDE, simply build the ``INSTALL`` target. This "
"step will install the appropriate header files, libraries, and executables. "
"For example:"
msgstr ""

#: ../../../guide/tutorial/index.rst:359
msgid "cmake --install ."
msgstr ""

#: ../../../guide/tutorial/index.rst:363
msgid ""
"The CMake variable :variable:`CMAKE_INSTALL_PREFIX` is used to determine the "
"root of where the files will be installed. If using the ``cmake --install`` "
"command, the installation prefix can be overridden via the ``--prefix`` "
"argument. For example:"
msgstr ""

#: ../../../guide/tutorial/index.rst:368
msgid "cmake --install . --prefix \"/home/myuser/installdir\""
msgstr ""

#: ../../../guide/tutorial/index.rst:372
msgid ""
"Navigate to the install directory and verify that the installed Tutorial "
"runs."
msgstr ""

#: ../../../guide/tutorial/index.rst:375
msgid "Testing Support"
msgstr ""

#: ../../../guide/tutorial/index.rst:377
msgid ""
"Next let's test our application. At the end of the top-level ``CMakeLists."
"txt`` file we can enable testing and then add a number of basic tests to "
"verify that the application is working correctly."
msgstr ""

#: ../../../guide/tutorial/index.rst:381
msgid ""
"enable_testing()\n"
"\n"
"# does the application run\n"
"add_test(NAME Runs COMMAND Tutorial 25)\n"
"\n"
"# does the usage message work?\n"
"add_test(NAME Usage COMMAND Tutorial)\n"
"set_tests_properties(Usage\n"
"  PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\"\n"
"  )\n"
"\n"
"# define a function to simplify adding tests\n"
"function(do_test target arg result)\n"
"  add_test(NAME Comp${arg} COMMAND ${target} ${arg})\n"
"  set_tests_properties(Comp${arg}\n"
"    PROPERTIES PASS_REGULAR_EXPRESSION ${result}\n"
"    )\n"
"endfunction(do_test)\n"
"\n"
"# do a bunch of result based tests\n"
"do_test(Tutorial 4 \"4 is 2\")\n"
"do_test(Tutorial 9 \"9 is 3\")\n"
"do_test(Tutorial 5 \"5 is 2.236\")\n"
"do_test(Tutorial 7 \"7 is 2.645\")\n"
"do_test(Tutorial 25 \"25 is 5\")\n"
"do_test(Tutorial -25 \"-25 is [-nan|nan|0]\")\n"
"do_test(Tutorial 0.0001 \"0.0001 is 0.01\")\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:385
msgid ""
"The first test simply verifies that the application runs, does not segfault "
"or otherwise crash, and has a zero return value. This is the basic form of a "
"CTest test."
msgstr ""

#: ../../../guide/tutorial/index.rst:389
msgid ""
"The next test makes use of the :prop_test:`PASS_REGULAR_EXPRESSION` test "
"property to verify that the output of the test contains certain strings. In "
"this case, verifying that the usage message is printed when an incorrect "
"number of arguments are provided."
msgstr ""

#: ../../../guide/tutorial/index.rst:394
msgid ""
"Lastly, we have a function called ``do_test`` that runs the application and "
"verifies that the computed square root is correct for given input. For each "
"invocation of ``do_test``, another test is added to the project with a name, "
"input, and expected results based on the passed arguments."
msgstr ""

#: ../../../guide/tutorial/index.rst:399
msgid ""
"Rebuild the application and then cd to the binary directory and run the :"
"manual:`ctest <ctest(1)>` executable: ``ctest -N`` and ``ctest -VV``. For "
"multi-config generators (e.g. Visual Studio), the configuration type must be "
"specified. To run tests in Debug mode, for example, use ``ctest -C Debug -"
"VV`` from the build directory (not the Debug subdirectory!). Alternatively, "
"build the ``RUN_TESTS`` target from the IDE."
msgstr ""

#: ../../../guide/tutorial/index.rst:407
msgid "Adding System Introspection (Step 5)"
msgstr ""

#: ../../../guide/tutorial/index.rst:409
msgid ""
"Let us consider adding some code to our project that depends on features the "
"target platform may not have. For this example, we will add some code that "
"depends on whether or not the target platform has the ``log`` and ``exp`` "
"functions. Of course almost every platform has these functions but for this "
"tutorial assume that they are not common."
msgstr ""

#: ../../../guide/tutorial/index.rst:415
msgid ""
"If the platform has ``log`` and ``exp`` then we will use them to compute the "
"square root in the ``mysqrt`` function. We first test for the availability "
"of these functions using the :module:`CheckSymbolExists` module in the top-"
"level ``CMakeLists.txt``. On some platforms, we will need to link to the m "
"library. If ``log`` and ``exp`` are not initially found, require the m "
"library and try again."
msgstr ""

#: ../../../guide/tutorial/index.rst:422
msgid ""
"We're going to use the new defines in ``TutorialConfig.h.in``, so be sure to "
"set them before that file is configured."
msgstr ""

#: ../../../guide/tutorial/index.rst:425
msgid ""
"include(CheckSymbolExists)\n"
"check_symbol_exists(log \"math.h\" HAVE_LOG)\n"
"check_symbol_exists(exp \"math.h\" HAVE_EXP)\n"
"if(NOT (HAVE_LOG AND HAVE_EXP))\n"
"  unset(HAVE_LOG CACHE)\n"
"  unset(HAVE_EXP CACHE)\n"
"  set(CMAKE_REQUIRED_LIBRARIES \"m\")\n"
"  check_symbol_exists(log \"math.h\" HAVE_LOG)\n"
"  check_symbol_exists(exp \"math.h\" HAVE_EXP)\n"
"  if(HAVE_LOG AND HAVE_EXP)\n"
"    target_link_libraries(MathFunctions PRIVATE m)\n"
"  endif()\n"
"endif()\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:430
msgid ""
"Now let's add these defines to ``TutorialConfig.h.in`` so that we can use "
"them from ``mysqrt.cxx``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:433
msgid ""
"// does the platform provide exp and log functions?\n"
"#cmakedefine HAVE_LOG\n"
"#cmakedefine HAVE_EXP"
msgstr ""

#: ../../../guide/tutorial/index.rst:439
msgid ""
"If ``log`` and ``exp`` are available on the system, then we will use them to "
"compute the square root in the ``mysqrt`` function. Add the following code "
"to the ``mysqrt`` function in ``MathFunctions/mysqrt.cxx`` (don't forget the "
"``#endif`` before returning the result!):"
msgstr ""

#: ../../../guide/tutorial/index.rst:444
msgid ""
"#if defined(HAVE_LOG) && defined(HAVE_EXP)\n"
"  double result = exp(log(x) * 0.5);\n"
"  std::cout << \"Computing sqrt of \" << x << \" to be \" << result\n"
"            << \" using log and exp\" << std::endl;\n"
"#else\n"
"  double result = x;\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:449
msgid "We will also need to modify ``mysqrt.cxx`` to include ``cmath``."
msgstr ""

#: ../../../guide/tutorial/index.rst:451
msgid "#include <cmath>\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:455
msgid ""
"Run the :manual:`cmake  <cmake(1)>` executable or the :manual:`cmake-gui "
"<cmake-gui(1)>` to configure the project and then build it with your chosen "
"build tool and run the Tutorial executable."
msgstr ""

#: ../../../guide/tutorial/index.rst:459
msgid ""
"You will notice that we're not using ``log`` and ``exp``, even if we think "
"they should be available. We should realize quickly that we have forgotten "
"to include ``TutorialConfig.h`` in ``mysqrt.cxx``."
msgstr ""

#: ../../../guide/tutorial/index.rst:463
msgid ""
"We will also need to update ``MathFunctions/CMakeLists.txt`` so ``mysqrt."
"cxx`` knows where this file is located:"
msgstr ""

#: ../../../guide/tutorial/index.rst:466
msgid ""
"target_include_directories(MathFunctions\n"
"          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"          PRIVATE ${CMAKE_BINARY_DIR}\n"
"          )"
msgstr ""

#: ../../../guide/tutorial/index.rst:473
msgid ""
"After making this update, go ahead and build the project again and run the "
"built Tutorial executable. If ``log`` and ``exp`` are still not being used, "
"open the generated ``TutorialConfig.h`` file from the build directory. Maybe "
"they aren't available on the current system?"
msgstr ""

#: ../../../guide/tutorial/index.rst:478
msgid "Which function gives better results now, sqrt or mysqrt?"
msgstr ""

#: ../../../guide/tutorial/index.rst:481
msgid "Specify Compile Definition"
msgstr ""

#: ../../../guide/tutorial/index.rst:483
msgid ""
"Is there a better place for us to save the ``HAVE_LOG`` and ``HAVE_EXP`` "
"values other than in ``TutorialConfig.h``? Let's try to use :command:"
"`target_compile_definitions`."
msgstr ""

#: ../../../guide/tutorial/index.rst:487
msgid ""
"First, remove the defines from ``TutorialConfig.h.in``. We no longer need to "
"include ``TutorialConfig.h`` from ``mysqrt.cxx`` or the extra include in "
"``MathFunctions/CMakeLists.txt``."
msgstr ""

#: ../../../guide/tutorial/index.rst:491
msgid ""
"Next, we can move the check for ``HAVE_LOG`` and ``HAVE_EXP`` to "
"``MathFunctions/CMakeLists.txt`` and then specify those values as "
"``PRIVATE`` compile definitions."
msgstr ""

#: ../../../guide/tutorial/index.rst:495
msgid ""
"include(CheckSymbolExists)\n"
"check_symbol_exists(log \"math.h\" HAVE_LOG)\n"
"check_symbol_exists(exp \"math.h\" HAVE_EXP)\n"
"if(NOT (HAVE_LOG AND HAVE_EXP))\n"
"  unset(HAVE_LOG CACHE)\n"
"  unset(HAVE_EXP CACHE)\n"
"  set(CMAKE_REQUIRED_LIBRARIES \"m\")\n"
"  check_symbol_exists(log \"math.h\" HAVE_LOG)\n"
"  check_symbol_exists(exp \"math.h\" HAVE_EXP)\n"
"  if(HAVE_LOG AND HAVE_EXP)\n"
"    target_link_libraries(MathFunctions PRIVATE m)\n"
"  endif()\n"
"endif()\n"
"\n"
"# add compile definitions\n"
"if(HAVE_LOG AND HAVE_EXP)\n"
"  target_compile_definitions(MathFunctions\n"
"                             PRIVATE \"HAVE_LOG\" \"HAVE_EXP\")\n"
"endif()\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:500
msgid ""
"After making these updates, go ahead and build the project again. Run the "
"built Tutorial executable and verify that the results are same as earlier in "
"this step."
msgstr ""

#: ../../../guide/tutorial/index.rst:505
msgid "Adding a Custom Command and Generated File (Step 6)"
msgstr ""

#: ../../../guide/tutorial/index.rst:507
msgid ""
"Suppose, for the purpose of this tutorial, we decide that we never want to "
"use the platform ``log`` and ``exp`` functions and instead would like to "
"generate a table of precomputed values to use in the ``mysqrt`` function. In "
"this section, we will create the table as part of the build process, and "
"then compile that table into our application."
msgstr ""

#: ../../../guide/tutorial/index.rst:513
msgid ""
"First, let's remove the check for the ``log`` and ``exp`` functions in "
"``MathFunctions/CMakeLists.txt``. Then remove the check for ``HAVE_LOG`` and "
"``HAVE_EXP`` from ``mysqrt.cxx``. At the same time, we can remove :code:"
"`#include <cmath>`."
msgstr ""

#: ../../../guide/tutorial/index.rst:518
msgid ""
"In the ``MathFunctions`` subdirectory, a new source file named ``MakeTable."
"cxx`` has been provided to generate the table."
msgstr ""

#: ../../../guide/tutorial/index.rst:521
msgid ""
"After reviewing the file, we can see that the table is produced as valid C++ "
"code and that the output filename is passed in as an argument."
msgstr ""

#: ../../../guide/tutorial/index.rst:524
msgid ""
"The next step is to add the appropriate commands to the ``MathFunctions/"
"CMakeLists.txt`` file to build the MakeTable executable and then run it as "
"part of the build process. A few commands are needed to accomplish this."
msgstr ""

#: ../../../guide/tutorial/index.rst:529
msgid ""
"First, at the top of ``MathFunctions/CMakeLists.txt``, the executable for "
"``MakeTable`` is added as any other executable would be added."
msgstr ""

#: ../../../guide/tutorial/index.rst:532
msgid ""
"add_executable(MakeTable MakeTable.cxx)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:537
msgid ""
"Then we add a custom command that specifies how to produce ``Table.h`` by "
"running MakeTable."
msgstr ""

#: ../../../guide/tutorial/index.rst:540
msgid ""
"add_custom_command(\n"
"  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"  DEPENDS MakeTable\n"
"  )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:545
msgid ""
"Next we have to let CMake know that ``mysqrt.cxx`` depends on the generated "
"file ``Table.h``. This is done by adding the generated ``Table.h`` to the "
"list of sources for the library MathFunctions."
msgstr ""

#: ../../../guide/tutorial/index.rst:549
msgid ""
"add_library(MathFunctions\n"
"            mysqrt.cxx\n"
"            ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"            )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:554
msgid ""
"We also have to add the current binary directory to the list of include "
"directories so that ``Table.h`` can be found and included by ``mysqrt.cxx``."
msgstr ""

#: ../../../guide/tutorial/index.rst:557
msgid ""
"target_include_directories(MathFunctions\n"
"          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"          PRIVATE ${CMAKE_CURRENT_BINARY_DIR}\n"
"          )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:562
msgid ""
"Now let's use the generated table. First, modify ``mysqrt.cxx`` to include "
"``Table.h``. Next, we can rewrite the mysqrt function to use the table:"
msgstr ""

#: ../../../guide/tutorial/index.rst:565
msgid ""
"double mysqrt(double x)\n"
"{\n"
"  if (x <= 0) {\n"
"    return 0;\n"
"  }\n"
"\n"
"  // use the table to help find an initial value\n"
"  double result = x;\n"
"  if (x >= 1 && x < 10) {\n"
"    std::cout << \"Use the table to help find an initial value \" << std::"
"endl;\n"
"    result = sqrtTable[static_cast<int>(x)];\n"
"  }\n"
"\n"
"  // do ten iterations\n"
"  for (int i = 0; i < 10; ++i) {\n"
"    if (result <= 0) {\n"
"      result = 0.1;\n"
"    }\n"
"    double delta = x - (result * result);\n"
"    result = result + 0.5 * delta / result;\n"
"    std::cout << \"Computing sqrt of \" << x << \" to be \" << result << "
"std::endl;\n"
"  }\n"
"\n"
"  return result;\n"
"}\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:569
msgid ""
"Run the :manual:`cmake  <cmake(1)>` executable or the :manual:`cmake-gui "
"<cmake-gui(1)>` to configure the project and then build it with your chosen "
"build tool."
msgstr ""

#: ../../../guide/tutorial/index.rst:573
msgid ""
"When this project is built it will first build the ``MakeTable`` executable. "
"It will then run ``MakeTable`` to produce ``Table.h``. Finally, it will "
"compile ``mysqrt.cxx`` which includes ``Table.h`` to produce the "
"MathFunctions library."
msgstr ""

#: ../../../guide/tutorial/index.rst:578
msgid "Run the Tutorial executable and verify that it is using the table."
msgstr ""

#: ../../../guide/tutorial/index.rst:581
msgid "Building an Installer (Step 7)"
msgstr ""

#: ../../../guide/tutorial/index.rst:583
msgid ""
"Next suppose that we want to distribute our project to other people so that "
"they can use it. We want to provide both binary and source distributions on "
"a variety of platforms. This is a little different from the install we did "
"previously in `Installing and Testing (Step 4)`_ , where we were installing "
"the binaries that we had built from the source code. In this example we will "
"be building installation packages that support binary installations and "
"package management features. To accomplish this we will use CPack to create "
"platform specific installers. Specifically we need to add a few lines to the "
"bottom of our top-level ``CMakeLists.txt`` file."
msgstr ""

#: ../../../guide/tutorial/index.rst:593
msgid ""
"include(InstallRequiredSystemLibraries)\n"
"set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/License."
"txt\")\n"
"set(CPACK_PACKAGE_VERSION_MAJOR \"${Tutorial_VERSION_MAJOR}\")\n"
"set(CPACK_PACKAGE_VERSION_MINOR \"${Tutorial_VERSION_MINOR}\")\n"
"include(CPack)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:597
msgid ""
"That is all there is to it. We start by including :module:"
"`InstallRequiredSystemLibraries`. This module will include any runtime "
"libraries that are needed by the project for the current platform. Next we "
"set some CPack variables to where we have stored the license and version "
"information for this project. The version information was set earlier in "
"this tutorial and the ``license.txt`` has been included in the top-level "
"source directory for this step."
msgstr ""

#: ../../../guide/tutorial/index.rst:605
msgid ""
"Finally we include the :module:`CPack module <CPack>` which will use these "
"variables and some other properties of the current system to setup an "
"installer."
msgstr ""

#: ../../../guide/tutorial/index.rst:609
msgid ""
"The next step is to build the project in the usual manner and then run the :"
"manual:`cpack <cpack(1)>` executable. To build a binary distribution, from "
"the binary directory run:"
msgstr ""

#: ../../../guide/tutorial/index.rst:613
msgid "cpack"
msgstr ""

#: ../../../guide/tutorial/index.rst:617
msgid ""
"To specify the generator, use the ``-G`` option. For multi-config builds, "
"use ``-C`` to specify the configuration. For example:"
msgstr ""

#: ../../../guide/tutorial/index.rst:620
msgid "cpack -G ZIP -C Debug"
msgstr ""

#: ../../../guide/tutorial/index.rst:624
msgid "To create a source distribution you would type:"
msgstr ""

#: ../../../guide/tutorial/index.rst:626
msgid "cpack --config CPackSourceConfig.cmake"
msgstr ""

#: ../../../guide/tutorial/index.rst:630
msgid ""
"Alternatively, run ``make package`` or right click the ``Package`` target "
"and ``Build Project`` from an IDE."
msgstr ""

#: ../../../guide/tutorial/index.rst:633
msgid ""
"Run the installer found in the binary directory. Then run the installed "
"executable and verify that it works."
msgstr ""

#: ../../../guide/tutorial/index.rst:637
msgid "Adding Support for a Dashboard (Step 8)"
msgstr ""

#: ../../../guide/tutorial/index.rst:639
msgid ""
"Adding support for submitting our test results to a dashboard is simple. We "
"already defined a number of tests for our project in `Testing Support`_. Now "
"we just have to run those tests and submit them to a dashboard. To include "
"support for dashboards we include the :module:`CTest` module in our top-"
"level ``CMakeLists.txt``."
msgstr ""

#: ../../../guide/tutorial/index.rst:645
msgid "Replace:"
msgstr ""

#: ../../../guide/tutorial/index.rst:647
msgid ""
"# enable testing\n"
"enable_testing()"
msgstr ""

#: ../../../guide/tutorial/index.rst:652
msgid "With:"
msgstr ""

#: ../../../guide/tutorial/index.rst:654
msgid ""
"# enable dashboard scripting\n"
"include(CTest)"
msgstr ""

#: ../../../guide/tutorial/index.rst:659
msgid ""
"The :module:`CTest` module will automatically call ``enable_testing()``, so "
"we can remove it from our CMake files."
msgstr ""

#: ../../../guide/tutorial/index.rst:662
msgid ""
"We will also need to create a ``CTestConfig.cmake`` file in the top-level "
"directory where we can specify the name of the project and where to submit "
"the dashboard."
msgstr ""

#: ../../../guide/tutorial/index.rst:666
msgid ""
"set(CTEST_PROJECT_NAME \"CMakeTutorial\")\n"
"set(CTEST_NIGHTLY_START_TIME \"00:00:00 EST\")\n"
"\n"
"set(CTEST_DROP_METHOD \"http\")\n"
"set(CTEST_DROP_SITE \"my.cdash.org\")\n"
"set(CTEST_DROP_LOCATION \"/submit.php?project=CMakeTutorial\")\n"
"set(CTEST_DROP_SITE_CDASH TRUE)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:669
msgid ""
"The :manual:`ctest <ctest(1)>` executable will read in this file when it "
"runs. To create a simple dashboard you can run the :manual:`cmake "
"<cmake(1)>` executable or the :manual:`cmake-gui <cmake-gui(1)>` to "
"configure the project, but do not build it yet. Instead, change directory to "
"the binary tree, and then run:"
msgstr ""

#: ../../../guide/tutorial/index.rst:675
msgid "ctest [-VV] -D Experimental"
msgstr ""

#: ../../../guide/tutorial/index.rst:677
msgid ""
"Remember, for multi-config generators (e.g. Visual Studio), the "
"configuration type must be specified::"
msgstr ""

#: ../../../guide/tutorial/index.rst:680
msgid "ctest [-VV] -C Debug -D Experimental"
msgstr ""

#: ../../../guide/tutorial/index.rst:682
msgid "Or, from an IDE, build the ``Experimental`` target."
msgstr ""

#: ../../../guide/tutorial/index.rst:684
msgid ""
"The :manual:`ctest <ctest(1)>` executable will build and test the project "
"and submit the results to Kitware's public dashboard: https://my.cdash.org/"
"index.php?project=CMakeTutorial."
msgstr ""

#: ../../../guide/tutorial/index.rst:689
msgid "Mixing Static and Shared (Step 9)"
msgstr ""

#: ../../../guide/tutorial/index.rst:691
msgid ""
"In this section we will show how the :variable:`BUILD_SHARED_LIBS` variable "
"can be used to control the default behavior of :command:`add_library`, and "
"allow control over how libraries without an explicit type (``STATIC``, "
"``SHARED``, ``MODULE`` or ``OBJECT``) are built."
msgstr ""

#: ../../../guide/tutorial/index.rst:696
msgid ""
"To accomplish this we need to add :variable:`BUILD_SHARED_LIBS` to the top-"
"level ``CMakeLists.txt``. We use the :command:`option` command as it allows "
"users to optionally select if the value should be ON or OFF."
msgstr ""

#: ../../../guide/tutorial/index.rst:700
msgid ""
"Next we are going to refactor MathFunctions to become a real library that "
"encapsulates using ``mysqrt`` or ``sqrt``, instead of requiring the calling "
"code to do this logic. This will also mean that ``USE_MYMATH`` will not "
"control building MathFunctions, but instead will control the behavior of "
"this library."
msgstr ""

#: ../../../guide/tutorial/index.rst:705
msgid ""
"The first step is to update the starting section of the top-level "
"``CMakeLists.txt`` to look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:708
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name and version\n"
"project(Tutorial VERSION 1.0)\n"
"\n"
"# specify the C++ standard\n"
"set(CMAKE_CXX_STANDARD 11)\n"
"set(CMAKE_CXX_STANDARD_REQUIRED True)\n"
"\n"
"# control where the static and shared libraries are built so that on "
"windows\n"
"# we don't need to tinker with the path to run the executable\n"
"set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\n"
"set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\n"
"set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\n"
"\n"
"option(BUILD_SHARED_LIBS \"Build using shared libraries\" ON)\n"
"\n"
"# configure a header file to pass the version number only\n"
"configure_file(TutorialConfig.h.in TutorialConfig.h)\n"
"\n"
"# add the MathFunctions library\n"
"add_subdirectory(MathFunctions)\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)\n"
"target_link_libraries(Tutorial PUBLIC MathFunctions)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:712
msgid ""
"Now that we have made MathFunctions always be used, we will need to update "
"the logic of that library. So, in ``MathFunctions/CMakeLists.txt`` we need "
"to create a SqrtLibrary that will conditionally be built and installed when "
"``USE_MYMATH`` is enabled. Now, since this is a tutorial, we are going to "
"explicitly require that SqrtLibrary is built statically."
msgstr ""

#: ../../../guide/tutorial/index.rst:718
msgid ""
"The end result is that ``MathFunctions/CMakeLists.txt`` should look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:720
msgid ""
"# add the library that runs\n"
"add_library(MathFunctions MathFunctions.cxx)\n"
"\n"
"# state that anybody linking to us needs to include the current source dir\n"
"# to find MathFunctions.h, while we don't.\n"
"target_include_directories(MathFunctions\n"
"                           INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"                           )\n"
"\n"
"# should we use our own math functions\n"
"option(USE_MYMATH \"Use tutorial provided math implementation\" ON)\n"
"if(USE_MYMATH)\n"
"\n"
"  target_compile_definitions(MathFunctions PRIVATE \"USE_MYMATH\")\n"
"\n"
"  # first we add the executable that generates the table\n"
"  add_executable(MakeTable MakeTable.cxx)\n"
"\n"
"  # add the command to generate the source code\n"
"  add_custom_command(\n"
"    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"    COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"    DEPENDS MakeTable\n"
"    )\n"
"\n"
"  # library that just does sqrt\n"
"  add_library(SqrtLibrary STATIC\n"
"              mysqrt.cxx\n"
"              ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"              )\n"
"\n"
"  # state that we depend on our binary dir to find Table.h\n"
"  target_include_directories(SqrtLibrary PRIVATE\n"
"                             ${CMAKE_CURRENT_BINARY_DIR}\n"
"                             )\n"
"\n"
"  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)\n"
"endif()\n"
"\n"
"# define the symbol stating we are using the declspec(dllexport) when\n"
"# building on windows\n"
"target_compile_definitions(MathFunctions PRIVATE \"EXPORTING_MYMATH\")\n"
"\n"
"# install rules\n"
"set(installable_libs MathFunctions)\n"
"if(TARGET SqrtLibrary)\n"
"  list(APPEND installable_libs SqrtLibrary)\n"
"endif()\n"
"install(TARGETS ${installable_libs} DESTINATION lib)\n"
"install(FILES MathFunctions.h DESTINATION include)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:724
msgid ""
"Next, update ``MathFunctions/mysqrt.cxx`` to use the ``mathfunctions`` and "
"``detail`` namespaces:"
msgstr ""

#: ../../../guide/tutorial/index.rst:727
msgid ""
"#include <iostream>\n"
"\n"
"#include \"MathFunctions.h\"\n"
"\n"
"// include the generated table\n"
"#include \"Table.h\"\n"
"\n"
"namespace mathfunctions {\n"
"namespace detail {\n"
"// a hack square root calculation using simple operations\n"
"double mysqrt(double x)\n"
"{\n"
"  if (x <= 0) {\n"
"    return 0;\n"
"  }\n"
"\n"
"  // use the table to help find an initial value\n"
"  double result = x;\n"
"  if (x >= 1 && x < 10) {\n"
"    std::cout << \"Use the table to help find an initial value \" << std::"
"endl;\n"
"    result = sqrtTable[static_cast<int>(x)];\n"
"  }\n"
"\n"
"  // do ten iterations\n"
"  for (int i = 0; i < 10; ++i) {\n"
"    if (result <= 0) {\n"
"      result = 0.1;\n"
"    }\n"
"    double delta = x - (result * result);\n"
"    result = result + 0.5 * delta / result;\n"
"    std::cout << \"Computing sqrt of \" << x << \" to be \" << result << "
"std::endl;\n"
"  }\n"
"\n"
"  return result;\n"
"}\n"
"}\n"
"}\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:730
msgid ""
"We also need to make some changes in ``tutorial.cxx``, so that it no longer "
"uses ``USE_MYMATH``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:733
msgid "Always include ``MathFunctions.h``"
msgstr ""

#: ../../../guide/tutorial/index.rst:734
msgid "Always use ``mathfunctions::sqrt``"
msgstr ""

#: ../../../guide/tutorial/index.rst:735
msgid "Don't include cmath"
msgstr ""

#: ../../../guide/tutorial/index.rst:737
msgid ""
"Finally, update ``MathFunctions/MathFunctions.h`` to use dll export defines:"
msgstr ""

#: ../../../guide/tutorial/index.rst:739
msgid ""
"\n"
"#if defined(_WIN32)\n"
"#  if defined(EXPORTING_MYMATH)\n"
"#    define DECLSPEC __declspec(dllexport)\n"
"#  else\n"
"#    define DECLSPEC __declspec(dllimport)\n"
"#  endif\n"
"#else // non windows\n"
"#  define DECLSPEC\n"
"#endif\n"
"\n"
"namespace mathfunctions {\n"
"double DECLSPEC sqrt(double x);\n"
"}\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:742
msgid ""
"At this point, if you build everything, you may notice that linking fails as "
"we are combining a static library without position independent code with a "
"library that has position independent code. The solution to this is to "
"explicitly set the :prop_tgt:`POSITION_INDEPENDENT_CODE` target property of "
"SqrtLibrary to be True no matter the build type."
msgstr ""

#: ../../../guide/tutorial/index.rst:748
msgid ""
"  # state that SqrtLibrary need PIC when the default is shared libraries\n"
"  set_target_properties(SqrtLibrary PROPERTIES\n"
"                        POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS}\n"
"                        )\n"
"\n"
"  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:752
msgid ""
"**Exercise**: We modified ``MathFunctions.h`` to use dll export defines. "
"Using CMake documentation can you find a helper module to simplify this?"
msgstr ""

#: ../../../guide/tutorial/index.rst:757
msgid "Adding Generator Expressions (Step 10)"
msgstr ""

#: ../../../guide/tutorial/index.rst:759
msgid ""
":manual:`Generator expressions <cmake-generator-expressions(7)>` are "
"evaluated during build system generation to produce information specific to "
"each build configuration."
msgstr ""

#: ../../../guide/tutorial/index.rst:763
msgid ""
":manual:`Generator expressions <cmake-generator-expressions(7)>` are allowed "
"in the context of many target properties, such as :prop_tgt:"
"`LINK_LIBRARIES`, :prop_tgt:`INCLUDE_DIRECTORIES`, :prop_tgt:"
"`COMPILE_DEFINITIONS` and others. They may also be used when using commands "
"to populate those properties, such as :command:`target_link_libraries`, :"
"command:`target_include_directories`, :command:`target_compile_definitions` "
"and others."
msgstr ""

#: ../../../guide/tutorial/index.rst:770
msgid ""
":manual:`Generator expressions <cmake-generator-expressions(7)>`  may be "
"used to enable conditional linking, conditional definitions used when "
"compiling, conditional include directories and more. The conditions may be "
"based on the build configuration, target properties, platform information or "
"any other queryable information."
msgstr ""

#: ../../../guide/tutorial/index.rst:776
msgid ""
"There are different types of :manual:`generator expressions <cmake-generator-"
"expressions(7)>` including Logical, Informational, and Output expressions."
msgstr ""

#: ../../../guide/tutorial/index.rst:780
msgid ""
"Logical expressions are used to create conditional output. The basic "
"expressions are the 0 and 1 expressions. A ``$<0:...>`` results in the empty "
"string, and ``<1:...>`` results in the content of \"...\".  They can also be "
"nested."
msgstr ""

#: ../../../guide/tutorial/index.rst:785
msgid ""
"A common usage of :manual:`generator expressions <cmake-generator-"
"expressions(7)>` is to conditionally add compiler flags, such as those for "
"language levels or warnings. A nice pattern is to associate this information "
"to an ``INTERFACE`` target allowing this information to propagate. Let's "
"start by constructing an ``INTERFACE`` target and specifying the required C+"
"+ standard level of ``11`` instead of using :variable:`CMAKE_CXX_STANDARD`."
msgstr ""

#: ../../../guide/tutorial/index.rst:793
msgid "So the following code:"
msgstr ""

#: ../../../guide/tutorial/index.rst:795
msgid ""
"\n"
"# specify the C++ standard\n"
"set(CMAKE_CXX_STANDARD 11)\n"
"set(CMAKE_CXX_STANDARD_REQUIRED True)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:800
msgid "Would be replaced with:"
msgstr ""

#: ../../../guide/tutorial/index.rst:802
msgid ""
"\n"
"add_library(tutorial_compiler_flags INTERFACE)\n"
"target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:808
msgid ""
"Next we add the desired compiler warning flags that we want for our project. "
"As warning flags vary based on the compiler we use the "
"``COMPILE_LANG_AND_ID`` generator expression to control which flags to apply "
"given a language and a set of compiler ids as seen below:"
msgstr ""

#: ../../../guide/tutorial/index.rst:813
msgid ""
"set(gcc_like_cxx \"$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,"
"GNU>\")\n"
"set(msvc_cxx \"$<COMPILE_LANG_AND_ID:CXX,MSVC>\")\n"
"target_compile_options(tutorial_compiler_flags INTERFACE\n"
"  \"$<${gcc_like_cxx}:$<BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-"
"Wunused>>\"\n"
"  \"$<${msvc_cxx}:$<BUILD_INTERFACE:-W3>>\"\n"
")\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:818
msgid ""
"Looking at this we see that the warning flags are encapsulated inside a "
"``BUILD_INTERFACE`` condition. This is done so that consumers of our "
"installed project will not inherit our warning flags."
msgstr ""

#: ../../../guide/tutorial/index.rst:823
msgid ""
"**Exercise**: Modify ``MathFunctions/CMakeLists.txt`` so that all targets "
"have a :command:`target_link_libraries` call to ``tutorial_compiler_flags``."
msgstr ""

#: ../../../guide/tutorial/index.rst:828
msgid "Adding Export Configuration (Step 11)"
msgstr ""

#: ../../../guide/tutorial/index.rst:830
msgid ""
"During `Installing and Testing (Step 4)`_ of the tutorial we added the "
"ability for CMake to install the library and headers of the project. During "
"`Building an Installer (Step 7)`_ we added the ability to package up this "
"information so it could be distributed to other people."
msgstr ""

#: ../../../guide/tutorial/index.rst:835
msgid ""
"The next step is to add the necessary information so that other CMake "
"projects can use our project, be it from a build directory, a local install "
"or when packaged."
msgstr ""

#: ../../../guide/tutorial/index.rst:839
msgid ""
"The first step is to update our :command:`install(TARGETS)` commands to not "
"only specify a ``DESTINATION`` but also an ``EXPORT``. The ``EXPORT`` "
"keyword generates and installs a CMake file containing code to import all "
"targets listed in the install command from the installation tree. So let's "
"go ahead and explicitly ``EXPORT`` the MathFunctions library by updating the "
"``install`` command in ``MathFunctions/CMakeLists.txt`` to look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:846
msgid ""
"set(installable_libs MathFunctions tutorial_compiler_flags)\n"
"if(TARGET SqrtLibrary)\n"
"  list(APPEND installable_libs SqrtLibrary)\n"
"endif()\n"
"install(TARGETS ${installable_libs}\n"
"        DESTINATION lib\n"
"        EXPORT MathFunctionsTargets)\n"
"install(FILES MathFunctions.h DESTINATION include)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:850
msgid ""
"Now that we have MathFunctions being exported, we also need to explicitly "
"install the generated ``MathFunctionsTargets.cmake`` file. This is done by "
"adding the following to the bottom of the top-level ``CMakeLists.txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:854
msgid ""
"install(EXPORT MathFunctionsTargets\n"
"  FILE MathFunctionsTargets.cmake\n"
"  DESTINATION lib/cmake/MathFunctions\n"
")\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:859
msgid ""
"At this point you should try and run CMake. If everything is setup properly "
"you will see that CMake will generate an error that looks like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:862
msgid ""
"Target \"MathFunctions\" INTERFACE_INCLUDE_DIRECTORIES property contains\n"
"path:\n"
"\n"
"  \"/Users/robert/Documents/CMakeClass/Tutorial/Step11/MathFunctions\"\n"
"\n"
"which is prefixed in the source directory."
msgstr ""

#: ../../../guide/tutorial/index.rst:871
msgid ""
"What CMake is trying to say is that during generating the export information "
"it will export a path that is intrinsically tied to the current machine and "
"will not be valid on other machines. The solution to this is to update the "
"MathFunctions :command:`target_include_directories` to understand that it "
"needs different ``INTERFACE`` locations when being used from within the "
"build directory and from an install / package. This means converting the :"
"command:`target_include_directories` call for MathFunctions to look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:879
msgid ""
"target_include_directories(MathFunctions\n"
"                           INTERFACE\n"
"                            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n"
"                            $<INSTALL_INTERFACE:include>\n"
"                           )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:884
msgid ""
"Once this has been updated, we can re-run CMake and verify that it doesn't "
"warn anymore."
msgstr ""

#: ../../../guide/tutorial/index.rst:887
msgid ""
"At this point, we have CMake properly packaging the target information that "
"is required but we will still need to generate a ``MathFunctionsConfig."
"cmake`` so that the CMake :command:`find_package` command can find our "
"project. So let's go ahead and add a new file to the top-level of the "
"project called ``Config.cmake.in`` with the following contents:"
msgstr ""

#: ../../../guide/tutorial/index.rst:893
msgid ""
"\n"
"@PACKAGE_INIT@\n"
"\n"
"include ( \"${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\" )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:895
msgid ""
"Then, to properly configure and install that file, add the following to the "
"bottom of the top-level ``CMakeLists.txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:898
msgid ""
"install(EXPORT MathFunctionsTargets\n"
"  FILE MathFunctionsTargets.cmake\n"
"  DESTINATION lib/cmake/MathFunctions\n"
")\n"
"\n"
"include(CMakePackageConfigHelpers)\n"
"# generate the config file that is includes the exports\n"
"configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in\n"
"  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\"\n"
"  INSTALL_DESTINATION \"lib/cmake/example\"\n"
"  NO_SET_AND_CHECK_MACRO\n"
"  NO_CHECK_REQUIRED_COMPONENTS_MACRO\n"
"  )\n"
"# generate the version file for the config file\n"
"write_basic_package_version_file(\n"
"  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\"\n"
"  VERSION \"${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}\"\n"
"  COMPATIBILITY AnyNewerVersion\n"
")\n"
"\n"
"# install the configuration file\n"
"install(FILES\n"
"  ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\n"
"  DESTINATION lib/cmake/MathFunctions\n"
"  )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:903
msgid ""
"At this point, we have generated a relocatable CMake Configuration for our "
"project that can be used after the project has been installed or packaged. "
"If we want our project to also be used from a build directory we only have "
"to add the following to the bottom of the top level ``CMakeLists.txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:908
msgid ""
"export(EXPORT MathFunctionsTargets\n"
"  FILE \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsTargets.cmake\"\n"
")\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:912
msgid ""
"With this export call we now generate a ``Targets.cmake``, allowing the "
"configured ``MathFunctionsConfig.cmake`` in the build directory to be used "
"by other projects, without needing it to be installed."
msgstr ""

#: ../../../guide/tutorial/index.rst:917
msgid "Packaging Debug and Release (Step 12)"
msgstr ""

#: ../../../guide/tutorial/index.rst:919
msgid ""
"**Note:** This example is valid for single-configuration generators and will "
"not work for multi-configuration generators (e.g. Visual Studio)."
msgstr ""

#: ../../../guide/tutorial/index.rst:922
msgid ""
"By default, CMake's model is that a build directory only contains a single "
"configuration, be it Debug, Release, MinSizeRel, or RelWithDebInfo. It is "
"possible, however, to setup CPack to bundle multiple build directories and "
"construct a package that contains multiple configurations of the same "
"project."
msgstr ""

#: ../../../guide/tutorial/index.rst:927
msgid ""
"First, we want to ensure that the debug and release builds use different "
"names for the executables and libraries that will be installed. Let's use "
"`d` as the postfix for the debug executable and libraries."
msgstr ""

#: ../../../guide/tutorial/index.rst:931
msgid ""
"Set :variable:`CMAKE_DEBUG_POSTFIX` near the beginning of the top-level "
"``CMakeLists.txt`` file:"
msgstr ""

#: ../../../guide/tutorial/index.rst:934
msgid ""
"\n"
"set(CMAKE_DEBUG_POSTFIX d)\n"
"\n"
"add_library(tutorial_compiler_flags INTERFACE)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:939
msgid "And the :prop_tgt:`DEBUG_POSTFIX` property on the tutorial executable:"
msgstr ""

#: ../../../guide/tutorial/index.rst:941
msgid ""
"add_executable(Tutorial tutorial.cxx)\n"
"set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX "
"${CMAKE_DEBUG_POSTFIX})\n"
"\n"
"target_link_libraries(Tutorial PUBLIC MathFunctions)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:946
msgid ""
"Let's also add version numbering to the MathFunctions library. In "
"``MathFunctions/CMakeLists.txt``, set the :prop_tgt:`VERSION` and :prop_tgt:"
"`SOVERSION` properties:"
msgstr ""

#: ../../../guide/tutorial/index.rst:950
msgid ""
"set_property(TARGET MathFunctions PROPERTY VERSION \"1.0.0\")\n"
"set_property(TARGET MathFunctions PROPERTY SOVERSION \"1\")\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:955
msgid ""
"From the ``Step12`` directory, create ``debug`` and ``release`` "
"subbdirectories. The layout will look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:958
msgid ""
"- Step12\n"
"   - debug\n"
"   - release"
msgstr ""

#: ../../../guide/tutorial/index.rst:964
msgid ""
"Now we need to setup debug and release builds. We can use :variable:"
"`CMAKE_BUILD_TYPE` to set the configuration type:"
msgstr ""

#: ../../../guide/tutorial/index.rst:967
msgid ""
"cd debug\n"
"cmake -DCMAKE_BUILD_TYPE=Debug ..\n"
"cmake --build .\n"
"cd ../release\n"
"cmake -DCMAKE_BUILD_TYPE=Release ..\n"
"cmake --build ."
msgstr ""

#: ../../../guide/tutorial/index.rst:976
msgid ""
"Now that both the debug and release builds are complete, we can use a custom "
"configuration file to package both builds into a single release. In the "
"``Step12`` directory, create a file called ``MultiCPackConfig.cmake``. In "
"this file, first include the default configuration file that was created by "
"the :manual:`cmake  <cmake(1)>` executable."
msgstr ""

#: ../../../guide/tutorial/index.rst:982
msgid ""
"Next, use the ``CPACK_INSTALL_CMAKE_PROJECTS`` variable to specify which "
"projects to install. In this case, we want to install both debug and release."
msgstr ""

#: ../../../guide/tutorial/index.rst:985
msgid ""
"include(\"release/CPackConfig.cmake\")\n"
"\n"
"set(CPACK_INSTALL_CMAKE_PROJECTS\n"
"    \"debug;Tutorial;ALL;/\"\n"
"    \"release;Tutorial;ALL;/\"\n"
"    )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:988
msgid ""
"From the ``Step12`` directory, run :manual:`cpack <cpack(1)>` specifying our "
"custom configuration file with the ``config`` option:"
msgstr ""

#: ../../../guide/tutorial/index.rst:991
msgid "cpack --config MultiCPackConfig.cmake"
msgstr ""
