# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2000-2019 Kitware, Inc. and Contributors
# This file is distributed under the same license as the CMake package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMake 3.16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-04 18:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko_KR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../guide/tutorial/index.rst:2
msgid "CMake Tutorial"
msgstr ""

#: ../../../guide/tutorial/index.rst:5
msgid "Contents"
msgstr ""

#: ../../../guide/tutorial/index.rst:8
msgid ""
"The CMake tutorial provides a step-by-step guide that covers common build "
"system issues that CMake helps address. Seeing how various topics all work "
"together in an example project can be very helpful. The tutorial "
"documentation and source code for examples can be found in the ``Help/guide/"
"tutorial`` directory of the CMake source code tree. Each step has its own "
"subdirectory containing code that may be used as a starting point. The "
"tutorial examples are progressive so that each step provides the complete "
"solution for the previous step."
msgstr ""

#: ../../../guide/tutorial/index.rst:18
msgid "A Basic Starting Point (Step 1)"
msgstr ""

#: ../../../guide/tutorial/index.rst:20
msgid ""
"The most basic project is an executable built from source code files. For "
"simple projects, a three line ``CMakeLists.txt`` file is all that is "
"required. This will be the starting point for our tutorial. Create a "
"``CMakeLists.txt`` file in the ``Step1`` directory that looks like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:25
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name\n"
"project(Tutorial)\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)"
msgstr ""

#: ../../../guide/tutorial/index.rst:36
msgid ""
"Note that this example uses lower case commands in the ``CMakeLists.txt`` "
"file. Upper, lower, and mixed case commands are supported by CMake. The "
"source code for ``tutorial.cxx`` is provided in the ``Step1`` directory and "
"can be used to compute the square root of a number."
msgstr ""

#: ../../../guide/tutorial/index.rst:42
msgid "Adding a Version Number and Configured Header File"
msgstr ""

#: ../../../guide/tutorial/index.rst:44
msgid ""
"The first feature we will add is to provide our executable and project with "
"a version number. While we could do this exclusively in the source code, "
"using ``CMakeLists.txt`` provides more flexibility."
msgstr ""

#: ../../../guide/tutorial/index.rst:48
msgid "First, modify the ``CMakeLists.txt`` file to set the version number."
msgstr ""

#: ../../../guide/tutorial/index.rst:50
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name and version\n"
"project(Tutorial VERSION 1.0)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:54
msgid ""
"Then, configure a header file to pass the version number to the source code:"
msgstr ""

#: ../../../guide/tutorial/index.rst:57
msgid ""
"configure_file(TutorialConfig.h.in TutorialConfig.h)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:62
msgid ""
"Since the configured file will be written into the binary tree, we must add "
"that directory to the list of paths to search for include files. Add the "
"following lines to the end of the ``CMakeLists.txt`` file:"
msgstr ""

#: ../../../guide/tutorial/index.rst:66 ../../../guide/tutorial/index.rst:280
msgid ""
"target_include_directories(Tutorial PUBLIC\n"
"                           \"${PROJECT_BINARY_DIR}\"\n"
"                           )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:70
msgid ""
"Using your favorite editor, create ``TutorialConfig.h.in`` in the source "
"directory with the following contents:"
msgstr ""

#: ../../../guide/tutorial/index.rst:73
msgid ""
"// the configured options and settings for Tutorial\n"
"#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@\n"
"#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:76
msgid ""
"When CMake configures this header file the values for "
"``@Tutorial_VERSION_MAJOR@`` and ``@Tutorial_VERSION_MINOR@`` will be "
"replaced."
msgstr ""

#: ../../../guide/tutorial/index.rst:80
msgid ""
"Next modify ``tutorial.cxx`` to include the configured header file, "
"``TutorialConfig.h``."
msgstr ""

#: ../../../guide/tutorial/index.rst:83
msgid ""
"Finally, let's print out the version number by updating ``tutorial.cxx`` as "
"follows:"
msgstr ""

#: ../../../guide/tutorial/index.rst:86
msgid ""
"  if (argc < 2) {\n"
"    // report version\n"
"    std::cout << argv[0] << \" Version \" << Tutorial_VERSION_MAJOR << \"."
"\"\n"
"              << Tutorial_VERSION_MINOR << std::endl;\n"
"    std::cout << \"Usage: \" << argv[0] << \" number\" << std::endl;\n"
"    return 1;\n"
"  }\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:92
msgid "Specify the C++ Standard"
msgstr ""

#: ../../../guide/tutorial/index.rst:94
msgid ""
"Next let's add some C++11 features to our project by replacing ``atof`` with "
"``std::stod`` in ``tutorial.cxx``.  At the same time, remove ``#include "
"<cstdlib>``."
msgstr ""

#: ../../../guide/tutorial/index.rst:98
msgid ""
"  const double inputValue = std::stod(argv[1]);\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:103
msgid ""
"We will need to explicitly state in the CMake code that it should use the "
"correct flags. The easiest way to enable support for a specific C++ standard "
"in CMake is by using the ``CMAKE_CXX_STANDARD`` variable. For this tutorial, "
"set the ``CMAKE_CXX_STANDARD`` variable in the ``CMakeLists.txt`` file to 11 "
"and ``CMAKE_CXX_STANDARD_REQUIRED`` to True:"
msgstr ""

#: ../../../guide/tutorial/index.rst:109
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name and version\n"
"project(Tutorial VERSION 1.0)\n"
"\n"
"# specify the C++ standard\n"
"set(CMAKE_CXX_STANDARD 11)\n"
"set(CMAKE_CXX_STANDARD_REQUIRED True)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:114
msgid "Build and Test"
msgstr ""

#: ../../../guide/tutorial/index.rst:116 ../../../guide/tutorial/index.rst:513
msgid ""
"Run **cmake** or **cmake-gui** to configure the project and then build it "
"with your chosen build tool."
msgstr ""

#: ../../../guide/tutorial/index.rst:119
msgid ""
"For example, from the command line we could navigate to the ``Help/guide/"
"tutorial`` directory of the CMake source code tree and run the following "
"commands:"
msgstr ""

#: ../../../guide/tutorial/index.rst:123
msgid ""
"mkdir Step1_build\n"
"cd Step1_build\n"
"cmake ../Step1\n"
"cmake --build ."
msgstr ""

#: ../../../guide/tutorial/index.rst:130
msgid ""
"Navigate to the directory where Tutorial was built (likely the make "
"directory or a Debug or Release build configuration subdirectory) and run "
"these commands:"
msgstr ""

#: ../../../guide/tutorial/index.rst:133
msgid ""
"Tutorial 4294967296\n"
"Tutorial 10\n"
"Tutorial"
msgstr ""

#: ../../../guide/tutorial/index.rst:140
msgid "Adding a Library (Step 2)"
msgstr ""

#: ../../../guide/tutorial/index.rst:142
msgid ""
"Now we will add a library to our project. This library will contain our own "
"implementation for computing the square root of a number. The executable can "
"then use this library instead of the standard square root function provided "
"by the compiler."
msgstr ""

#: ../../../guide/tutorial/index.rst:147
msgid ""
"For this tutorial we will put the library into a subdirectory called "
"``MathFunctions``. This directory already contains a header file, "
"``MathFunctions.h``, and a source file ``mysqrt.cxx``. The source file has "
"one function called ``mysqrt`` that provides similar functionality to the "
"compiler's ``sqrt`` function."
msgstr ""

#: ../../../guide/tutorial/index.rst:153
msgid ""
"Add the following one line ``CMakeLists.txt`` file to the ``MathFunctions`` "
"directory:"
msgstr ""

#: ../../../guide/tutorial/index.rst:156
msgid "add_library(MathFunctions mysqrt.cxx)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:159
msgid ""
"To make use of the new library we will add an ``add_subdirectory`` call in "
"the top-level ``CMakeLists.txt`` file so that the library will get built. We "
"add the new library to the executable, and add ``MathFunctions`` as an "
"include directory so that the ``mqsqrt.h`` header file can be found. The "
"last few lines of the top-level ``CMakeLists.txt`` file should now look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:165
msgid ""
"# add the MathFunctions library\n"
"add_subdirectory(MathFunctions)\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)\n"
"\n"
"target_link_libraries(Tutorial PUBLIC MathFunctions)\n"
"\n"
"# add the binary tree to the search path for include files\n"
"# so that we will find TutorialConfig.h\n"
"target_include_directories(Tutorial PUBLIC\n"
"                          \"${PROJECT_BINARY_DIR}\"\n"
"                          \"${PROJECT_SOURCE_DIR}/MathFunctions\"\n"
"                          )"
msgstr ""

#: ../../../guide/tutorial/index.rst:182
msgid ""
"Now let us make the MathFunctions library optional. While for the tutorial "
"there really isnâ€™t any need to do so, for larger projects this is a common "
"occurrence. The first step is to add an option to the top-level ``CMakeLists."
"txt`` file."
msgstr ""

#: ../../../guide/tutorial/index.rst:187
msgid ""
"option(USE_MYMATH \"Use tutorial provided math implementation\" ON)\n"
"\n"
"# configure a header file to pass some of the CMake settings\n"
"# to the source code\n"
"configure_file(TutorialConfig.h.in TutorialConfig.h)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:192
msgid ""
"This option will be displayed in the CMake GUI and ccmake with a default "
"value of ON that can be changed by the user. This setting will be stored in "
"the cache so that the user does not need to set the value each time they run "
"CMake on a build directory."
msgstr ""

#: ../../../guide/tutorial/index.rst:197
msgid ""
"The next change is to make building and linking the MathFunctions library "
"conditional. To do this we change the end of the top-level ``CMakeLists."
"txt`` file to look like the following:"
msgstr ""

#: ../../../guide/tutorial/index.rst:201
msgid ""
"if(USE_MYMATH)\n"
"  add_subdirectory(MathFunctions)\n"
"  list(APPEND EXTRA_LIBS MathFunctions)\n"
"  list(APPEND EXTRA_INCLUDES \"${PROJECT_SOURCE_DIR}/MathFunctions\")\n"
"endif()\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)\n"
"\n"
"target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})\n"
"\n"
"# add the binary tree to the search path for include files\n"
"# so that we will find TutorialConfig.h\n"
"target_include_directories(Tutorial PUBLIC\n"
"                           \"${PROJECT_BINARY_DIR}\"\n"
"                           ${EXTRA_INCLUDES}\n"
"                           )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:205
msgid ""
"Note the use of the variable ``EXTRA_LIBS`` to collect up any optional "
"libraries to later be linked into the executable. The variable "
"``EXTRA_INCLUDES`` is used similarly for optional header files. This is a "
"classic approach when dealing with many optional components, we will cover "
"the modern approach in the next step."
msgstr ""

#: ../../../guide/tutorial/index.rst:211
msgid ""
"The corresponding changes to the source code are fairly straightforward. "
"First, in ``tutorial.cxx``, include the ``MathFunctions.h`` header if we "
"need it:"
msgstr ""

#: ../../../guide/tutorial/index.rst:214
msgid ""
"#ifdef USE_MYMATH\n"
"#  include \"MathFunctions.h\"\n"
"#endif\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:219
msgid ""
"Then, in the same file, make ``USE_MYMATH`` control which square root "
"function is used:"
msgstr ""

#: ../../../guide/tutorial/index.rst:222
msgid ""
"#ifdef USE_MYMATH\n"
"  const double outputValue = mysqrt(inputValue);\n"
"#else\n"
"  const double outputValue = sqrt(inputValue);\n"
"#endif\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:227
msgid ""
"Since the source code now requires ``USE_MYMATH`` we can add it to "
"``TutorialConfig.h.in`` with the following line:"
msgstr ""

#: ../../../guide/tutorial/index.rst:230
msgid "#cmakedefine USE_MYMATH\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:234
msgid ""
"**Exercise**: Why is it important that we configure ``TutorialConfig.h.in`` "
"after the option for ``USE_MYMATH``? What would happen if we inverted the "
"two?"
msgstr ""

#: ../../../guide/tutorial/index.rst:237
msgid ""
"Run **cmake** or **cmake-gui** to configure the project and then build it "
"with your chosen build tool. Then run the built Tutorial executable."
msgstr ""

#: ../../../guide/tutorial/index.rst:240
msgid ""
"Use ccmake or the CMake GUI to update the value of ``USE_MYMATH``. Rebuild "
"and run the tutorial again. Which function gives better results, sqrt or "
"mysqrt?"
msgstr ""

#: ../../../guide/tutorial/index.rst:244
msgid "Adding Usage Requirements for Library (Step 3)"
msgstr ""

#: ../../../guide/tutorial/index.rst:246
msgid ""
"Usage requirements allow for far better control over a library or "
"executable's link and include line while also giving more control over the "
"transitive property of targets inside CMake. The primary commands that "
"leverage usage requirements are:"
msgstr ""

#: ../../../guide/tutorial/index.rst:251
msgid "``target_compile_definitions``"
msgstr ""

#: ../../../guide/tutorial/index.rst:252
msgid "``target_compile_options``"
msgstr ""

#: ../../../guide/tutorial/index.rst:253
msgid "``target_include_directories``"
msgstr ""

#: ../../../guide/tutorial/index.rst:254
msgid "``target_link_libraries``"
msgstr ""

#: ../../../guide/tutorial/index.rst:256
msgid ""
"Let's refactor our code from `Adding a Library (Step 2)`_ to use the modern "
"CMake approach of usage requirements. We first state that anybody linking to "
"MathFunctions needs to include the current source directory, while "
"MathFunctions itself doesn't. So  this can become an ``INTERFACE`` usage "
"requirement."
msgstr ""

#: ../../../guide/tutorial/index.rst:262
msgid ""
"Remember ``INTERFACE`` means things that consumers require but the producer "
"doesn't. Add the following lines to the end of ``MathFunctions/CMakeLists."
"txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:265
msgid ""
"target_include_directories(MathFunctions\n"
"          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"          )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:269
msgid ""
"Now that we've specified usage requirements for MathFunctions we can safely "
"remove our uses of the ``EXTRA_INCLUDES`` variable from the top-level "
"``CMakeLists.txt``, here:"
msgstr ""

#: ../../../guide/tutorial/index.rst:273
msgid ""
"if(USE_MYMATH)\n"
"  add_subdirectory(MathFunctions)\n"
"  list(APPEND EXTRA_LIBS MathFunctions)\n"
"endif()\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:278
msgid "And here:"
msgstr ""

#: ../../../guide/tutorial/index.rst:284
msgid ""
"Once this is done, run **cmake** or **cmake-gui** to configure the project "
"and then build it with your chosen build tool or by using ``cmake --build ."
"`` from the build directory."
msgstr ""

#: ../../../guide/tutorial/index.rst:289
msgid "Installing and Testing (Step 4)"
msgstr ""

#: ../../../guide/tutorial/index.rst:291
msgid ""
"Now we can start adding install rules and testing support to our project."
msgstr ""

#: ../../../guide/tutorial/index.rst:294
msgid "Install Rules"
msgstr ""

#: ../../../guide/tutorial/index.rst:296
msgid ""
"The install rules are fairly simple: for MathFunctions we want to install "
"the library and header file and for the application we want to install the "
"executable and configured header."
msgstr ""

#: ../../../guide/tutorial/index.rst:300
msgid "So to the end of ``MathFunctions/CMakeLists.txt`` we add:"
msgstr ""

#: ../../../guide/tutorial/index.rst:302
msgid ""
"install(TARGETS MathFunctions DESTINATION lib)\n"
"install(FILES MathFunctions.h DESTINATION include)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:306
msgid "And to the end of the top-level ``CMakeLists.txt`` we add:"
msgstr ""

#: ../../../guide/tutorial/index.rst:308
msgid ""
"install(TARGETS Tutorial DESTINATION bin)\n"
"install(FILES \"${PROJECT_BINARY_DIR}/TutorialConfig.h\"\n"
"  DESTINATION include\n"
"  )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:313
msgid ""
"That is all that is needed to create a basic local install of the tutorial."
msgstr ""

#: ../../../guide/tutorial/index.rst:315
msgid ""
"Run **cmake** or **cmake-gui** to configure the project and then build it "
"with your chosen build tool. Run the install step by typing ``cmake --"
"install .`` (introduced in 3.15, older versions of CMake must use ``make "
"install``) from the command line, or build the ``INSTALL`` target from an "
"IDE. This will install the appropriate header files, libraries, and "
"executables."
msgstr ""

#: ../../../guide/tutorial/index.rst:322
msgid ""
"The CMake variable ``CMAKE_INSTALL_PREFIX`` is used to determine the root of "
"where the files will be installed. If using ``cmake --install`` a custom "
"installation directory can be given via ``--prefix`` argument. For multi-"
"configuration tools, use the ``--config`` argument to specify the "
"configuration."
msgstr ""

#: ../../../guide/tutorial/index.rst:328
msgid "Verify that the installed Tutorial runs."
msgstr ""

#: ../../../guide/tutorial/index.rst:331
msgid "Testing Support"
msgstr ""

#: ../../../guide/tutorial/index.rst:333
msgid ""
"Next let's test our application. At the end of the top-level ``CMakeLists."
"txt`` file we can enable testing and then add a number of basic tests to "
"verify that the application is working correctly."
msgstr ""

#: ../../../guide/tutorial/index.rst:337
msgid ""
"enable_testing()\n"
"\n"
"# does the application run\n"
"add_test(NAME Runs COMMAND Tutorial 25)\n"
"\n"
"# does the usage message work?\n"
"add_test(NAME Usage COMMAND Tutorial)\n"
"set_tests_properties(Usage\n"
"  PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\"\n"
"  )\n"
"\n"
"# define a function to simplify adding tests\n"
"function(do_test target arg result)\n"
"  add_test(NAME Comp${arg} COMMAND ${target} ${arg})\n"
"  set_tests_properties(Comp${arg}\n"
"    PROPERTIES PASS_REGULAR_EXPRESSION ${result}\n"
"    )\n"
"endfunction(do_test)\n"
"\n"
"# do a bunch of result based tests\n"
"do_test(Tutorial 4 \"4 is 2\")\n"
"do_test(Tutorial 9 \"9 is 3\")\n"
"do_test(Tutorial 5 \"5 is 2.236\")\n"
"do_test(Tutorial 7 \"7 is 2.645\")\n"
"do_test(Tutorial 25 \"25 is 5\")\n"
"do_test(Tutorial -25 \"-25 is [-nan|nan|0]\")\n"
"do_test(Tutorial 0.0001 \"0.0001 is 0.01\")\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:341
msgid ""
"The first test simply verifies that the application runs, does not segfault "
"or otherwise crash, and has a zero return value. This is the basic form of a "
"CTest test."
msgstr ""

#: ../../../guide/tutorial/index.rst:345
msgid ""
"The next test makes use of the ``PASS_REGULAR_EXPRESSION`` test property to "
"verify that the output of the test contains certain strings. In this case, "
"verifying that the usage message is printed when an incorrect number of "
"arguments are provided."
msgstr ""

#: ../../../guide/tutorial/index.rst:350
msgid ""
"Lastly, we have a function called ``do_test`` that runs the application and "
"verifies that the computed square root is correct for given input. For each "
"invocation of ``do_test``, another test is added to the project with a name, "
"input, and expected results based on the passed arguments."
msgstr ""

#: ../../../guide/tutorial/index.rst:355
msgid ""
"Rebuild the application and then cd to the binary directory and run ``ctest -"
"N`` and ``ctest -VV``. For multi-config generators (e.g. Visual Studio), the "
"configuration type must be specified. To run tests in Debug mode, for "
"example, use ``ctest -C Debug -VV`` from the build directory (not the Debug "
"subdirectory!). Alternatively, build the ``RUN_TESTS`` target from the IDE."
msgstr ""

#: ../../../guide/tutorial/index.rst:363
msgid "Adding System Introspection (Step 5)"
msgstr ""

#: ../../../guide/tutorial/index.rst:365
msgid ""
"Let us consider adding some code to our project that depends on features the "
"target platform may not have. For this example, we will add some code that "
"depends on whether or not the target platform has the ``log`` and ``exp`` "
"functions. Of course almost every platform has these functions but for this "
"tutorial assume that they are not common."
msgstr ""

#: ../../../guide/tutorial/index.rst:371
msgid ""
"If the platform has ``log`` and ``exp`` then we will use them to compute the "
"square root in the ``mysqrt`` function. We first test for the availability "
"of these functions using the ``CheckSymbolExists`` module in the top-level "
"``CMakeLists.txt``. We're going to use the new defines in ``TutorialConfig.h."
"in``, so be sure to set them before that file is configured."
msgstr ""

#: ../../../guide/tutorial/index.rst:377
msgid ""
"include(CheckSymbolExists)\n"
"set(CMAKE_REQUIRED_LIBRARIES \"m\")\n"
"check_symbol_exists(log \"math.h\" HAVE_LOG)\n"
"check_symbol_exists(exp \"math.h\" HAVE_EXP)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:382
msgid ""
"Now let's add these defines to ``TutorialConfig.h.in`` so that we can use "
"them from ``mysqrt.cxx``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:385
msgid ""
"// does the platform provide exp and log functions?\n"
"#cmakedefine HAVE_LOG\n"
"#cmakedefine HAVE_EXP"
msgstr ""

#: ../../../guide/tutorial/index.rst:391
msgid ""
"Modify ``mysqrt.cxx`` to include cmath. Next, in that same file in the "
"``mysqrt`` function we can provide an alternate implementation based on "
"``log`` and ``exp`` if they are available on the system using the following "
"code (don't forget the ``#endif`` before returning the result!):"
msgstr ""

#: ../../../guide/tutorial/index.rst:396
msgid ""
"#if defined(HAVE_LOG) && defined(HAVE_EXP)\n"
"  double result = exp(log(x) * 0.5);\n"
"  std::cout << \"Computing sqrt of \" << x << \" to be \" << result\n"
"            << \" using log and exp\" << std::endl;\n"
"#else\n"
"  double result = x;\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:401
msgid ""
"Run **cmake** or **cmake-gui** to configure the project and then build it "
"with your chosen build tool and run the Tutorial executable."
msgstr ""

#: ../../../guide/tutorial/index.rst:404
msgid ""
"You will notice that we're not using ``log`` and ``exp``, even if we think "
"they should be available. We should realize quickly that we have forgotten "
"to include ``TutorialConfig.h`` in ``mysqrt.cxx``."
msgstr ""

#: ../../../guide/tutorial/index.rst:408
msgid ""
"We will also need to update ``MathFunctions/CMakeLists.txt`` so ``mysqrt."
"cxx`` knows where this file is located:"
msgstr ""

#: ../../../guide/tutorial/index.rst:411
msgid ""
"target_include_directories(MathFunctions\n"
"          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"          PRIVATE ${CMAKE_BINARY_DIR}\n"
"          )"
msgstr ""

#: ../../../guide/tutorial/index.rst:418
msgid ""
"After making this update, go ahead and build the project again and run the "
"built Tutorial executable. If ``log`` and ``exp`` are still not being used, "
"open the generated ``TutorialConfig.h`` file from the build directory. Maybe "
"they aren't available on the current system?"
msgstr ""

#: ../../../guide/tutorial/index.rst:423
msgid "Which function gives better results now, sqrt or mysqrt?"
msgstr ""

#: ../../../guide/tutorial/index.rst:426
msgid "Specify Compile Definition"
msgstr ""

#: ../../../guide/tutorial/index.rst:428
msgid ""
"Is there a better place for us to save the ``HAVE_LOG`` and ``HAVE_EXP`` "
"values other than in ``TutorialConfig.h``? Let's try to use "
"``target_compile_definitions``."
msgstr ""

#: ../../../guide/tutorial/index.rst:432
msgid ""
"First, remove the defines from ``TutorialConfig.h.in``. We no longer need to "
"include ``TutorialConfig.h`` from ``mysqrt.cxx`` or the extra include in "
"``MathFunctions/CMakeLists.txt``."
msgstr ""

#: ../../../guide/tutorial/index.rst:436
msgid ""
"Next, we can move the check for ``HAVE_LOG`` and ``HAVE_EXP`` to "
"``MathFunctions/CMakeLists.txt`` and then specify those values as "
"``PRIVATE`` compile definitions."
msgstr ""

#: ../../../guide/tutorial/index.rst:440
msgid ""
"include(CheckSymbolExists)\n"
"set(CMAKE_REQUIRED_LIBRARIES \"m\")\n"
"check_symbol_exists(log \"math.h\" HAVE_LOG)\n"
"check_symbol_exists(exp \"math.h\" HAVE_EXP)\n"
"\n"
"if(HAVE_LOG AND HAVE_EXP)\n"
"  target_compile_definitions(MathFunctions\n"
"                             PRIVATE \"HAVE_LOG\" \"HAVE_EXP\")\n"
"endif()\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:445
msgid ""
"After making these updates, go ahead and build the project again. Run the "
"built Tutorial executable and verify that the results are same as earlier in "
"this step."
msgstr ""

#: ../../../guide/tutorial/index.rst:450
msgid "Adding a Custom Command and Generated File (Step 6)"
msgstr ""

#: ../../../guide/tutorial/index.rst:452
msgid ""
"Suppose, for the purpose of this tutorial, we decide that we never want to "
"use the platform ``log`` and ``exp`` functions and instead would like to "
"generate a table of precomputed values to use in the ``mysqrt`` function. In "
"this section, we will create the table as part of the build process, and "
"then compile that table into our application."
msgstr ""

#: ../../../guide/tutorial/index.rst:458
msgid ""
"First, let's remove the check for the ``log`` and ``exp`` functions in "
"``MathFunctions/CMakeLists.txt``. Then remove the check for ``HAVE_LOG`` and "
"``HAVE_EXP`` from ``mysqrt.cxx``. At the same time, we can remove :code:"
"`#include <cmath>`."
msgstr ""

#: ../../../guide/tutorial/index.rst:463
msgid ""
"In the ``MathFunctions`` subdirectory, a new source file named ``MakeTable."
"cxx`` has been provided to generate the table."
msgstr ""

#: ../../../guide/tutorial/index.rst:466
msgid ""
"After reviewing the file, we can see that the table is produced as valid C++ "
"code and that the output filename is passed in as an argument."
msgstr ""

#: ../../../guide/tutorial/index.rst:469
msgid ""
"The next step is to add the appropriate commands to the ``MathFunctions/"
"CMakeLists.txt`` file to build the MakeTable executable and then run it as "
"part of the build process. A few commands are needed to accomplish this."
msgstr ""

#: ../../../guide/tutorial/index.rst:474
msgid ""
"First, at the top of ``MathFunctions/CMakeLists.txt``, the executable for "
"``MakeTable`` is added as any other executable would be added."
msgstr ""

#: ../../../guide/tutorial/index.rst:477
msgid ""
"add_executable(MakeTable MakeTable.cxx)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:482
msgid ""
"Then we add a custom command that specifies how to produce ``Table.h`` by "
"running MakeTable."
msgstr ""

#: ../../../guide/tutorial/index.rst:485
msgid ""
"add_custom_command(\n"
"  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"  DEPENDS MakeTable\n"
"  )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:490
msgid ""
"Next we have to let CMake know that ``mysqrt.cxx`` depends on the generated "
"file ``Table.h``. This is done by adding the generated ``Table.h`` to the "
"list of sources for the library MathFunctions."
msgstr ""

#: ../../../guide/tutorial/index.rst:494
msgid ""
"add_library(MathFunctions\n"
"            mysqrt.cxx\n"
"            ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"            )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:499
msgid ""
"We also have to add the current binary directory to the list of include "
"directories so that ``Table.h`` can be found and included by ``mysqrt.cxx``."
msgstr ""

#: ../../../guide/tutorial/index.rst:502
msgid ""
"target_include_directories(MathFunctions\n"
"          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"          PRIVATE ${CMAKE_CURRENT_BINARY_DIR}\n"
"          )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:506
msgid ""
"Now let's use the generated table. First, modify ``mysqrt.cxx`` to include "
"``Table.h``. Next, we can rewrite the mysqrt function to use the table:"
msgstr ""

#: ../../../guide/tutorial/index.rst:509
msgid ""
"double mysqrt(double x)\n"
"{\n"
"  if (x <= 0) {\n"
"    return 0;\n"
"  }\n"
"\n"
"  // use the table to help find an initial value\n"
"  double result = x;\n"
"  if (x >= 1 && x < 10) {\n"
"    std::cout << \"Use the table to help find an initial value \" << std::"
"endl;\n"
"    result = sqrtTable[static_cast<int>(x)];\n"
"  }\n"
"\n"
"  // do ten iterations\n"
"  for (int i = 0; i < 10; ++i) {\n"
"    if (result <= 0) {\n"
"      result = 0.1;\n"
"    }\n"
"    double delta = x - (result * result);\n"
"    result = result + 0.5 * delta / result;\n"
"    std::cout << \"Computing sqrt of \" << x << \" to be \" << result << "
"std::endl;\n"
"  }\n"
"\n"
"  return result;\n"
"}\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:516
msgid ""
"When this project is built it will first build the ``MakeTable`` executable. "
"It will then run ``MakeTable`` to produce ``Table.h``. Finally, it will "
"compile ``mysqrt.cxx`` which includes ``Table.h`` to produce the "
"MathFunctions library."
msgstr ""

#: ../../../guide/tutorial/index.rst:521
msgid "Run the Tutorial executable and verify that it is using the table."
msgstr ""

#: ../../../guide/tutorial/index.rst:524
msgid "Building an Installer (Step 7)"
msgstr ""

#: ../../../guide/tutorial/index.rst:526
msgid ""
"Next suppose that we want to distribute our project to other people so that "
"they can use it. We want to provide both binary and source distributions on "
"a variety of platforms. This is a little different from the install we did "
"previously in `Installing and Testing (Step 4)`_ , where we were installing "
"the binaries that we had built from the source code. In this example we will "
"be building installation packages that support binary installations and "
"package management features. To accomplish this we will use CPack to create "
"platform specific installers. Specifically we need to add a few lines to the "
"bottom of our top-level ``CMakeLists.txt`` file."
msgstr ""

#: ../../../guide/tutorial/index.rst:536
msgid ""
"include(InstallRequiredSystemLibraries)\n"
"set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/License."
"txt\")\n"
"set(CPACK_PACKAGE_VERSION_MAJOR \"${Tutorial_VERSION_MAJOR}\")\n"
"set(CPACK_PACKAGE_VERSION_MINOR \"${Tutorial_VERSION_MINOR}\")\n"
"include(CPack)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:540
msgid ""
"That is all there is to it. We start by including "
"``InstallRequiredSystemLibraries``. This module will include any runtime "
"libraries that are needed by the project for the current platform. Next we "
"set some CPack variables to where we have stored the license and version "
"information for this project. The version information was set earlier in "
"this tutorial and the ``license.txt`` has been included in the top-level "
"source directory for this step."
msgstr ""

#: ../../../guide/tutorial/index.rst:548
msgid ""
"Finally we include the CPack module which will use these variables and some "
"other properties of the current system to setup an installer."
msgstr ""

#: ../../../guide/tutorial/index.rst:551
msgid ""
"The next step is to build the project in the usual manner and then run CPack "
"on it. To build a binary distribution, from the binary directory run:"
msgstr ""

#: ../../../guide/tutorial/index.rst:554
msgid "cpack"
msgstr ""

#: ../../../guide/tutorial/index.rst:558
msgid ""
"To specify the generator, use the ``-G`` option. For multi-config builds, "
"use ``-C`` to specify the configuration. For example:"
msgstr ""

#: ../../../guide/tutorial/index.rst:561
msgid "cpack -G ZIP -C Debug"
msgstr ""

#: ../../../guide/tutorial/index.rst:565
msgid "To create a source distribution you would type:"
msgstr ""

#: ../../../guide/tutorial/index.rst:567
msgid "cpack --config CPackSourceConfig.cmake"
msgstr ""

#: ../../../guide/tutorial/index.rst:571
msgid ""
"Alternatively, run ``make package`` or right click the ``Package`` target "
"and ``Build Project`` from an IDE."
msgstr ""

#: ../../../guide/tutorial/index.rst:574
msgid ""
"Run the installer found in the binary directory. Then run the installed "
"executable and verify that it works."
msgstr ""

#: ../../../guide/tutorial/index.rst:578
msgid "Adding Support for a Dashboard (Step 8)"
msgstr ""

#: ../../../guide/tutorial/index.rst:580
msgid ""
"Adding support for submitting our test results to a dashboard is very easy. "
"We already defined a number of tests for our project in `Testing Support`_. "
"Now we just have to run those tests and submit them to a dashboard. To "
"include support for dashboards we include the CTest module in our top-level "
"``CMakeLists.txt``."
msgstr ""

#: ../../../guide/tutorial/index.rst:585
msgid "Replace:"
msgstr ""

#: ../../../guide/tutorial/index.rst:587
msgid ""
"# enable testing\n"
"enable_testing()"
msgstr ""

#: ../../../guide/tutorial/index.rst:592
msgid "With:"
msgstr ""

#: ../../../guide/tutorial/index.rst:594
msgid ""
"# enable dashboard scripting\n"
"include(CTest)"
msgstr ""

#: ../../../guide/tutorial/index.rst:599
msgid ""
"The CTest module will automatically call ``enable_testing()``, so we can "
"remove it from our CMake files."
msgstr ""

#: ../../../guide/tutorial/index.rst:602
msgid ""
"We will also need to create a ``CTestConfig.cmake`` file in the top-level "
"directory where we can specify the name of the project and where to submit "
"the dashboard."
msgstr ""

#: ../../../guide/tutorial/index.rst:606
msgid ""
"set(CTEST_PROJECT_NAME \"CMakeTutorial\")\n"
"set(CTEST_NIGHTLY_START_TIME \"00:00:00 EST\")\n"
"\n"
"set(CTEST_DROP_METHOD \"http\")\n"
"set(CTEST_DROP_SITE \"my.cdash.org\")\n"
"set(CTEST_DROP_LOCATION \"/submit.php?project=CMakeTutorial\")\n"
"set(CTEST_DROP_SITE_CDASH TRUE)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:609
msgid ""
"CTest will read in this file when it runs. To create a simple dashboard you "
"can run **cmake** or **cmake-gui** to configure the project, but do not "
"build it yet. Instead, change directory to the binary tree, and then run::"
msgstr ""

#: ../../../guide/tutorial/index.rst:613
msgid "ctest [-VV] -D Experimental"
msgstr ""

#: ../../../guide/tutorial/index.rst:615
msgid ""
"Remember, for multi-config generators (e.g. Visual Studio), the "
"configuration type must be specified::"
msgstr ""

#: ../../../guide/tutorial/index.rst:618
msgid "ctest [-VV] -C Debug -D Experimental"
msgstr ""

#: ../../../guide/tutorial/index.rst:620
msgid "Or, from an IDE, build the ``Experimental`` target."
msgstr ""

#: ../../../guide/tutorial/index.rst:622
msgid ""
"``ctest`` will build and test the project and submit the results to the "
"Kitware public dashboard. The results of your dashboard will be uploaded to "
"Kitware's public dashboard here: https://my.cdash.org/index.php?"
"project=CMakeTutorial."
msgstr ""

#: ../../../guide/tutorial/index.rst:627
msgid "Mixing Static and Shared (Step 9)"
msgstr ""

#: ../../../guide/tutorial/index.rst:629
msgid ""
"In this section we will show how by using the ``BUILD_SHARED_LIBS`` variable "
"we can control the default behavior of ``add_library``, and allow control "
"over how libraries without an explicit type (``STATIC``, ``SHARED``, "
"``MODULE`` or ``OBJECT``) are built."
msgstr ""

#: ../../../guide/tutorial/index.rst:634
msgid ""
"To accomplish this we need to add ``BUILD_SHARED_LIBS`` to the top-level "
"``CMakeLists.txt``. We use the ``option`` command as it allows users to "
"optionally select if the value should be On or Off."
msgstr ""

#: ../../../guide/tutorial/index.rst:638
msgid ""
"Next we are going to refactor MathFunctions to become a real library that "
"encapsulates using ``mysqrt`` or ``sqrt``, instead of requiring the calling "
"code to do this logic. This will also mean that ``USE_MYMATH`` will not "
"control building MathFuctions, but instead will control the behavior of this "
"library."
msgstr ""

#: ../../../guide/tutorial/index.rst:643
msgid ""
"The first step is to update the starting section of the top-level "
"``CMakeLists.txt`` to look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:646
msgid ""
"cmake_minimum_required(VERSION 3.10)\n"
"\n"
"# set the project name and version\n"
"project(Tutorial VERSION 1.0)\n"
"\n"
"# specify the C++ standard\n"
"set(CMAKE_CXX_STANDARD 11)\n"
"set(CMAKE_CXX_STANDARD_REQUIRED True)\n"
"\n"
"# control where the static and shared libraries are built so that on "
"windows\n"
"# we don't need to tinker with the path to run the executable\n"
"set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\n"
"set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\n"
"set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\n"
"\n"
"option(BUILD_SHARED_LIBS \"Build using shared libraries\" ON)\n"
"\n"
"# configure a header file to pass the version number only\n"
"configure_file(TutorialConfig.h.in TutorialConfig.h)\n"
"\n"
"# add the MathFunctions library\n"
"add_subdirectory(MathFunctions)\n"
"\n"
"# add the executable\n"
"add_executable(Tutorial tutorial.cxx)\n"
"target_link_libraries(Tutorial PUBLIC MathFunctions)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:650
msgid ""
"Now that we have made MathFunctions always be used, we will need to update "
"the logic of that library. So, in ``MathFunctions/CMakeLists.txt`` we need "
"to create a SqrtLibrary that will conditionally be built when ``USE_MYMATH`` "
"is enabled. Now, since this is a tutorial, we are going to explicitly "
"require that SqrtLibrary is built statically."
msgstr ""

#: ../../../guide/tutorial/index.rst:656
msgid ""
"The end result is that ``MathFunctions/CMakeLists.txt`` should look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:658
msgid ""
"# add the library that runs\n"
"add_library(MathFunctions MathFunctions.cxx)\n"
"\n"
"# state that anybody linking to us needs to include the current source dir\n"
"# to find MathFunctions.h, while we don't.\n"
"target_include_directories(MathFunctions\n"
"                           INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n"
"                           )\n"
"\n"
"# should we use our own math functions\n"
"option(USE_MYMATH \"Use tutorial provided math implementation\" ON)\n"
"if(USE_MYMATH)\n"
"\n"
"  target_compile_definitions(MathFunctions PRIVATE \"USE_MYMATH\")\n"
"\n"
"  # first we add the executable that generates the table\n"
"  add_executable(MakeTable MakeTable.cxx)\n"
"\n"
"  # add the command to generate the source code\n"
"  add_custom_command(\n"
"    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"    COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"    DEPENDS MakeTable\n"
"    )\n"
"\n"
"  # library that just does sqrt\n"
"  add_library(SqrtLibrary STATIC\n"
"              mysqrt.cxx\n"
"              ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n"
"              )\n"
"\n"
"  # state that we depend on our binary dir to find Table.h\n"
"  target_include_directories(SqrtLibrary PRIVATE\n"
"                             ${CMAKE_CURRENT_BINARY_DIR}\n"
"                             )\n"
"\n"
"  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)\n"
"endif()\n"
"\n"
"# define the symbol stating we are using the declspec(dllexport) when\n"
"# building on windows\n"
"target_compile_definitions(MathFunctions PRIVATE \"EXPORTING_MYMATH\")\n"
"\n"
"# install rules\n"
"install(TARGETS MathFunctions DESTINATION lib)\n"
"install(FILES MathFunctions.h DESTINATION include)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:662
msgid ""
"Next, update ``MathFunctions/mysqrt.cxx`` to use the ``mathfunctions`` and "
"``detail`` namespaces:"
msgstr ""

#: ../../../guide/tutorial/index.rst:665
msgid ""
"#include <iostream>\n"
"\n"
"#include \"MathFunctions.h\"\n"
"\n"
"// include the generated table\n"
"#include \"Table.h\"\n"
"\n"
"namespace mathfunctions {\n"
"namespace detail {\n"
"// a hack square root calculation using simple operations\n"
"double mysqrt(double x)\n"
"{\n"
"  if (x <= 0) {\n"
"    return 0;\n"
"  }\n"
"\n"
"  // use the table to help find an initial value\n"
"  double result = x;\n"
"  if (x >= 1 && x < 10) {\n"
"    std::cout << \"Use the table to help find an initial value \" << std::"
"endl;\n"
"    result = sqrtTable[static_cast<int>(x)];\n"
"  }\n"
"\n"
"  // do ten iterations\n"
"  for (int i = 0; i < 10; ++i) {\n"
"    if (result <= 0) {\n"
"      result = 0.1;\n"
"    }\n"
"    double delta = x - (result * result);\n"
"    result = result + 0.5 * delta / result;\n"
"    std::cout << \"Computing sqrt of \" << x << \" to be \" << result << "
"std::endl;\n"
"  }\n"
"\n"
"  return result;\n"
"}\n"
"}\n"
"}\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:668
msgid ""
"We also need to make some changes in ``tutorial.cxx``, so that it no longer "
"uses ``USE_MYMATH``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:671
msgid "Always include ``MathFunctions.h``"
msgstr ""

#: ../../../guide/tutorial/index.rst:672
msgid "Always use ``mathfunctions::sqrt``"
msgstr ""

#: ../../../guide/tutorial/index.rst:673
msgid "Don't include cmath"
msgstr ""

#: ../../../guide/tutorial/index.rst:675
msgid ""
"Finally, update ``MathFunctions/MathFunctions.h`` to use dll export defines:"
msgstr ""

#: ../../../guide/tutorial/index.rst:677
msgid ""
"\n"
"#if defined(_WIN32)\n"
"#  if defined(EXPORTING_MYMATH)\n"
"#    define DECLSPEC __declspec(dllexport)\n"
"#  else\n"
"#    define DECLSPEC __declspec(dllimport)\n"
"#  endif\n"
"#else // non windows\n"
"#  define DECLSPEC\n"
"#endif\n"
"\n"
"namespace mathfunctions {\n"
"double DECLSPEC sqrt(double x);\n"
"}\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:680
msgid ""
"At this point, if you build everything, you will notice that linking fails "
"as we are combining a static library without position independent code with "
"a library that has position independent code. The solution to this is to "
"explicitly set the ``POSITION_INDEPENDENT_CODE`` target property of "
"SqrtLibrary to be True no matter the build type."
msgstr ""

#: ../../../guide/tutorial/index.rst:686
msgid ""
"  # state that SqrtLibrary need PIC when the default is shared libraries\n"
"  set_target_properties(SqrtLibrary PROPERTIES\n"
"                        POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS}\n"
"                        )\n"
"\n"
"  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:690
msgid ""
"**Exercise**: We modified ``MathFunctions.h`` to use dll export defines. "
"Using CMake documentation can you find a helper module to simplify this?"
msgstr ""

#: ../../../guide/tutorial/index.rst:695
msgid "Adding Generator Expressions (Step 10)"
msgstr ""

#: ../../../guide/tutorial/index.rst:697
msgid ""
"Generator expressions are evaluated during build system generation to "
"produce information specific to each build configuration."
msgstr ""

#: ../../../guide/tutorial/index.rst:700
msgid ""
"Generator expressions are allowed in the context of many target properties, "
"such as ``LINK_LIBRARIES``, ``INCLUDE_DIRECTORIES``, ``COMPILE_DEFINITIONS`` "
"and others. They may also be used when using commands to populate those "
"properties, such as ``target_link_libraries()``, "
"``target_include_directories()``, ``target_compile_definitions()`` and "
"others."
msgstr ""

#: ../../../guide/tutorial/index.rst:707
msgid ""
"Generator expressions may be used to enable conditional linking, conditional "
"definitions used when compiling, conditional include directories and more. "
"The conditions may be based on the build configuration, target properties, "
"platform information or any other queryable information."
msgstr ""

#: ../../../guide/tutorial/index.rst:712
msgid ""
"There are different types of generator expressions including Logical, "
"Informational, and Output expressions."
msgstr ""

#: ../../../guide/tutorial/index.rst:715
msgid ""
"Logical expressions are used to create conditional output. The basic "
"expressions are the 0 and 1 expressions. A ``$<0:...>`` results in the empty "
"string, and ``<1:...>`` results in the content of \"...\".  They can also be "
"nested."
msgstr ""

#: ../../../guide/tutorial/index.rst:720
msgid ""
"A common usage of generator expressions is to conditionally add compiler "
"flags, such as those for language levels or warnings. A nice pattern is to "
"associate this information to an ``INTERFACE`` target allowing this "
"information to propagate. Lets start by constructing an ``INTERFACE`` target "
"and specifying the required C++ standard level of ``11`` instead of using "
"``CMAKE_CXX_STANDARD``."
msgstr ""

#: ../../../guide/tutorial/index.rst:727
msgid "So the following code:"
msgstr ""

#: ../../../guide/tutorial/index.rst:729
msgid ""
"\n"
"# specify the C++ standard\n"
"set(CMAKE_CXX_STANDARD 11)\n"
"set(CMAKE_CXX_STANDARD_REQUIRED True)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:734
msgid "Would be replaced with:"
msgstr ""

#: ../../../guide/tutorial/index.rst:736
msgid ""
"\n"
"add_library(tutorial_compiler_flags INTERFACE)\n"
"target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:742
msgid ""
"Next we add the desired compiler warning flags that we want for our project. "
"As warning flags vary based on the compiler we use the "
"``COMPILE_LANG_AND_ID`` generator expression to control which flags to apply "
"given a language and a set of compiler ids as seen below:"
msgstr ""

#: ../../../guide/tutorial/index.rst:748
msgid ""
"set(gcc_like_cxx \"$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,"
"GNU>\")\n"
"set(msvc_cxx \"$<COMPILE_LANG_AND_ID:CXX,MSVC>\")\n"
"target_compile_options(tutorial_compiler_flags INTERFACE\n"
"  \"$<${gcc_like_cxx}:$<BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-"
"Wunused>>\"\n"
"  \"$<${msvc_cxx}:$<BUILD_INTERFACE:-W3>>\"\n"
")\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:753
msgid ""
"Looking at this we see that the warning flags are encapsulated inside a "
"``BUILD_INTERFACE`` condition. This is done so that consumers of our "
"installed project will not inherit our warning flags."
msgstr ""

#: ../../../guide/tutorial/index.rst:758
msgid ""
"**Exercise**: Modify ``MathFunctions/CMakeLists.txt`` so that all targets "
"have a ``target_link_libraries()`` call to ``tutorial_compiler_flags``."
msgstr ""

#: ../../../guide/tutorial/index.rst:763
msgid "Adding Export Configuration (Step 11)"
msgstr ""

#: ../../../guide/tutorial/index.rst:765
msgid ""
"During `Installing and Testing (Step 4)`_ of the tutorial we added the "
"ability for CMake to install the library and headers of the project. During "
"`Building an Installer (Step 7)`_ we added the ability to package up this "
"information so it could be distributed to other people."
msgstr ""

#: ../../../guide/tutorial/index.rst:770
msgid ""
"The next step is to add the necessary information so that other CMake "
"projects can use our project, be it from a build directory, a local install "
"or when packaged."
msgstr ""

#: ../../../guide/tutorial/index.rst:774
msgid ""
"The first step is to update our ``install(TARGETS)`` commands to not only "
"specify a ``DESTINATION`` but also an ``EXPORT``. The ``EXPORT`` keyword "
"generates and installs a CMake file containing code to import all targets "
"listed in the install command from the installation tree. So let's go ahead "
"and explicitly ``EXPORT`` the MathFunctions library by updating the "
"``install`` command in ``MathFunctions/CMakeLists.txt`` to look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:781
msgid ""
"install(TARGETS MathFunctions tutorial_compiler_flags\n"
"        DESTINATION lib\n"
"        EXPORT MathFunctionsTargets)\n"
"install(FILES MathFunctions.h DESTINATION include)\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:785
msgid ""
"Now that we have MathFunctions being exported, we also need to explicitly "
"install the generated ``MathFunctionsTargets.cmake`` file. This is done by "
"adding the following to the bottom of the top-level ``CMakeLists.txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:789
msgid ""
"install(EXPORT MathFunctionsTargets\n"
"  FILE MathFunctionsTargets.cmake\n"
"  DESTINATION lib/cmake/MathFunctions\n"
")\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:794
msgid ""
"At this point you should try and run CMake. If everything is setup properly "
"you will see that CMake will generate an error that looks like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:797
msgid ""
"Target \"MathFunctions\" INTERFACE_INCLUDE_DIRECTORIES property contains\n"
"path:\n"
"\n"
"  \"/Users/robert/Documents/CMakeClass/Tutorial/Step11/MathFunctions\"\n"
"\n"
"which is prefixed in the source directory."
msgstr ""

#: ../../../guide/tutorial/index.rst:806
msgid ""
"What CMake is trying to say is that during generating the export information "
"it will export a path that is intrinsically tied to the current machine and "
"will not be valid on other machines. The solution to this is to update the "
"MathFunctions ``target_include_directories`` to understand that it needs "
"different ``INTERFACE`` locations when being used from within the build "
"directory and from an install / package. This means converting the "
"``target_include_directories`` call for MathFunctions to look like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:814
msgid ""
"target_include_directories(MathFunctions\n"
"                           INTERFACE\n"
"                            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n"
"                            $<INSTALL_INTERFACE:include>\n"
"                           )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:819
msgid ""
"Once this has been updated, we can re-run CMake and verify that it doesn't "
"warn anymore."
msgstr ""

#: ../../../guide/tutorial/index.rst:822
msgid ""
"At this point, we have CMake properly packaging the target information that "
"is required but we will still need to generate a ``MathFunctionsConfig."
"cmake`` so that the CMake ``find_package`` command can find our project. So "
"let's go ahead and add a new file to the top-level of the project called "
"``Config.cmake.in`` with the following contents:"
msgstr ""

#: ../../../guide/tutorial/index.rst:828
msgid ""
"\n"
"@PACKAGE_INIT@\n"
"\n"
"include ( \"${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\" )\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:830
msgid ""
"Then, to properly configure and install that file, add the following to the "
"bottom of the top-level ``CMakeLists.txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:833
msgid ""
"install(EXPORT MathFunctionsTargets\n"
"  FILE MathFunctionsTargets.cmake\n"
"  DESTINATION lib/cmake/MathFunctions\n"
")\n"
"\n"
"include(CMakePackageConfigHelpers)\n"
"# generate the config file that is includes the exports\n"
"configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in\n"
"  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\"\n"
"  INSTALL_DESTINATION \"lib/cmake/example\"\n"
"  NO_SET_AND_CHECK_MACRO\n"
"  NO_CHECK_REQUIRED_COMPONENTS_MACRO\n"
"  )\n"
"# generate the version file for the config file\n"
"write_basic_package_version_file(\n"
"  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\"\n"
"  VERSION \"${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}\"\n"
"  COMPATIBILITY AnyNewerVersion\n"
")\n"
"\n"
"# install the configuration file\n"
"install(FILES\n"
"  ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\n"
"  DESTINATION lib/cmake/MathFunctions\n"
"  )\n"
"\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:838
msgid ""
"At this point, we have generated a relocatable CMake Configuration for our "
"project that can be used after the project has been installed or packaged. "
"If we want our project to also be used from a build directory we only have "
"to add the following to the bottom of the top level ``CMakeLists.txt``:"
msgstr ""

#: ../../../guide/tutorial/index.rst:843
msgid ""
"export(EXPORT MathFunctionsTargets\n"
"  FILE \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsTargets.cmake\"\n"
")\n"
msgstr ""

#: ../../../guide/tutorial/index.rst:847
msgid ""
"With this export call we now generate a ``Targets.cmake``, allowing the "
"configured ``MathFunctionsConfig.cmake`` in the build directory to be used "
"by other projects, without needing it to be installed."
msgstr ""

#: ../../../guide/tutorial/index.rst:852
msgid "Import a CMake Project (Consumer)"
msgstr ""

#: ../../../guide/tutorial/index.rst:854
msgid ""
"This example shows how a project can find other CMake packages that generate "
"``Config.cmake`` files."
msgstr ""

#: ../../../guide/tutorial/index.rst:857
msgid ""
"It also shows how to state a project's external dependencies when generating "
"a ``Config.cmake``."
msgstr ""

#: ../../../guide/tutorial/index.rst:861
msgid "Packaging Debug and Release (MultiPackage)"
msgstr ""

#: ../../../guide/tutorial/index.rst:863
msgid ""
"By default CMake's model is that a build directory only contains a single "
"configuration, be it Debug, Release, MinSizeRel, or RelWithDebInfo."
msgstr ""

#: ../../../guide/tutorial/index.rst:866
msgid ""
"But it is possible to setup CPack to bundle multiple build directories at "
"the same time to build a package that contains multiple configurations of "
"the same project."
msgstr ""

#: ../../../guide/tutorial/index.rst:870
msgid ""
"First we need to construct a directory called ``multi_config``, which will "
"contain all the builds that we want to package together."
msgstr ""

#: ../../../guide/tutorial/index.rst:873
msgid ""
"Second create a ``debug`` and ``release`` directory underneath "
"``multi_config``. At the end you should have a layout that looks like:"
msgstr ""

#: ../../../guide/tutorial/index.rst:876
msgid ""
"â”€ multi_config\n"
"    â”œâ”€â”€ debug\n"
"    â””â”€â”€ release"
msgstr ""

#: ../../../guide/tutorial/index.rst:882
msgid ""
"Now we need to setup debug and release builds, which would roughly entail "
"the following:"
msgstr ""

#: ../../../guide/tutorial/index.rst:885
msgid ""
"cd debug\n"
"cmake -DCMAKE_BUILD_TYPE=Debug ../../MultiPackage/\n"
"cmake --build .\n"
"cd ../release\n"
"cmake -DCMAKE_BUILD_TYPE=Release ../../MultiPackage/\n"
"cmake --build .\n"
"cd .."
msgstr ""

#: ../../../guide/tutorial/index.rst:896
msgid ""
"Now that both the debug and release builds are complete, we can use a custom "
"``MultiCPackConfig.cmake`` file to package both builds into a single release."
msgstr ""

#: ../../../guide/tutorial/index.rst:900
msgid "cpack --config ../../MultiPackage/MultiCPackConfig.cmake"
msgstr ""
