# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2000-2018 Kitware, Inc. and Contributors
# This file is distributed under the same license as the CMake package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMake 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-04 17:55+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../../Modules/FetchContent.cmake:6
msgid "FetchContent"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:9
msgid "Contents"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:13
msgid "Overview"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:15
msgid ""
"This module enables populating content at configure time via any method "
"supported by the :module:`ExternalProject` module.  Whereas :command:"
"`ExternalProject_Add` downloads at build time, the ``FetchContent`` module "
"makes content available immediately, allowing the configure step to use the "
"content in commands like :command:`add_subdirectory`, :command:`include` or :"
"command:`file` operations."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:22
msgid ""
"Content population details would normally be defined separately from the "
"command that performs the actual population.  Projects should also check "
"whether the content has already been populated somewhere else in the project "
"hierarchy.  Typical usage would look something like this:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:27
msgid ""
"FetchContent_Declare(\n"
"  googletest\n"
"  GIT_REPOSITORY https://github.com/google/googletest.git\n"
"  GIT_TAG        release-1.8.0\n"
")\n"
"\n"
"FetchContent_GetProperties(googletest)\n"
"if(NOT googletest_POPULATED)\n"
"  FetchContent_Populate(googletest)\n"
"  add_subdirectory(${googletest_SOURCE_DIR} ${googletest_BINARY_DIR})\n"
"endif()"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:41
msgid ""
"When using the above pattern with a hierarchical project arrangement, "
"projects at higher levels in the hierarchy are able to define or override "
"the population details of content specified anywhere lower in the project "
"hierarchy.  The ability to detect whether content has already been populated "
"ensures that even if multiple child projects want certain content to be "
"available, the first one to populate it wins.  The other child project can "
"simply make use of the already available content instead of repeating the "
"population for itself.  See the :ref:`Examples <fetch-content-examples>` "
"section which demonstrates this scenario."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:52
msgid ""
"The ``FetchContent`` module also supports defining and populating content in "
"a single call, with no check for whether the content has been populated "
"elsewhere in the project already.  This is a more low level operation and "
"would not normally be the way the module is used, but it is sometimes useful "
"as part of implementing some higher level feature or to populate some "
"content in CMake's script mode."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:61
msgid "Declaring Content Details"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:65
msgid "FetchContent_Declare(<name> <contentOptions>...)"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:69
msgid ""
"The ``FetchContent_Declare()`` function records the options that describe "
"how to populate the specified content, but if such details have already been "
"recorded earlier in this project (regardless of where in the project "
"hierarchy), this and all later calls for the same content ``<name>`` are "
"ignored.  This \"first to record, wins\" approach is what allows "
"hierarchical projects to have parent projects override content details of "
"child projects."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:76
msgid ""
"The content ``<name>`` can be any string without spaces, but good practice "
"would be to use only letters, numbers and underscores.  The name will be "
"treated case-insensitively and it should be obvious for the content it "
"represents, often being the name of the child project or the value given to "
"its top level :command:`project` command (if it is a CMake project). For "
"well-known public projects, the name should generally be the official name "
"of the project.  Choosing an unusual name makes it unlikely that other "
"projects needing that same content will use the same name, leading to the "
"content being populated multiple times."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:86
msgid ""
"The ``<contentOptions>`` can be any of the download or update/patch options "
"that the :command:`ExternalProject_Add` command understands.  The configure, "
"build, install and test steps are explicitly disabled and therefore options "
"related to them will be ignored.  In most cases, ``<contentOptions>`` will "
"just be a couple of options defining the download method and method-specific "
"details like a commit tag or archive hash.  For example:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:93
msgid ""
"FetchContent_Declare(\n"
"  googletest\n"
"  GIT_REPOSITORY https://github.com/google/googletest.git\n"
"  GIT_TAG        release-1.8.0\n"
")\n"
"\n"
"FetchContent_Declare(\n"
"  myCompanyIcons\n"
"  URL      https://intranet.mycompany.com/assets/iconset_1.12.tar.gz\n"
"  URL_HASH 5588a7b18261c20068beabfb4f530b87\n"
")\n"
"\n"
"FetchContent_Declare(\n"
"  myCompanyCertificates\n"
"  SVN_REPOSITORY svn+ssh://svn.mycompany.com/srv/svn/trunk/certs\n"
"  SVN_REVISION   -r12345\n"
")"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:114
msgid "Populating The Content"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:118
msgid "FetchContent_Populate( <name> )"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:122
msgid ""
"In most cases, the only argument given to ``FetchContent_Populate()`` is the "
"``<name>``.  When used this way, the command assumes the content details "
"have been recorded by an earlier call to :command:`FetchContent_Declare`.  "
"The details are stored in a global property, so they are unaffected by "
"things like variable or directory scope.  Therefore, it doesn't matter where "
"in the project the details were previously declared, as long as they have "
"been declared before the call to ``FetchContent_Populate()``.  Those saved "
"details are then used to construct a call to :command:`ExternalProject_Add` "
"in a private sub-build to perform the content population immediately.  The "
"implementation of ``ExternalProject_Add()`` ensures that if the content has "
"already been populated in a previous CMake run, that content will be reused "
"rather than repopulating them again.  For the common case where population "
"involves downloading content, the cost of the download is only paid once."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:136
msgid ""
"An internal global property records when a particular content population "
"request has been processed.  If ``FetchContent_Populate()`` is called more "
"than once for the same content name within a configure run, the second call "
"will halt with an error.  Projects can and should check whether content "
"population has already been processed with the :command:"
"`FetchContent_GetProperties` command before calling "
"``FetchContent_Populate()``."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:144
msgid ""
"``FetchContent_Populate()`` will set three variables in the scope of the "
"caller; ``<lcName>_POPULATED``, ``<lcName>_SOURCE_DIR`` and "
"``<lcName>_BINARY_DIR``, where ``<lcName>`` is the lowercased ``<name>``. "
"``<lcName>_POPULATED`` will always be set to ``True`` by the call. "
"``<lcName>_SOURCE_DIR`` is the location where the content can be found upon "
"return (it will have already been populated), while ``<lcName>_BINARY_DIR`` "
"is a directory intended for use as a corresponding build directory.  The "
"main use case for the two directory variables is to call :command:"
"`add_subdirectory` immediately after population, i.e.:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:154
msgid ""
"FetchContent_Populate(FooBar ...)\n"
"add_subdirectory(${foobar_SOURCE_DIR} ${foobar_BINARY_DIR})"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:159
msgid ""
"The values of the three variables can also be retrieved from anywhere in the "
"project hierarchy using the :command:`FetchContent_GetProperties` command."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:162
msgid ""
"A number of cache variables influence the behavior of all content population "
"performed using details saved from a :command:`FetchContent_Declare` call:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:175
msgid "``FETCHCONTENT_BASE_DIR``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:166
msgid ""
"In most cases, the saved details do not specify any options relating to the "
"directories to use for the internal sub-build, final source and build areas. "
"It is generally best to leave these decisions up to the ``FetchContent`` "
"module to handle on the project's behalf.  The ``FETCHCONTENT_BASE_DIR`` "
"cache variable controls the point under which all content population "
"directories are collected, but in most cases developers would not need to "
"change this.  The default location is ``${CMAKE_BINARY_DIR}/_deps``, but if "
"developers change this value, they should aim to keep the path short and "
"just below the top level of the build tree to avoid running into path length "
"problems on Windows."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:182
msgid "``FETCHCONTENT_QUIET``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:178
msgid ""
"The logging output during population can be quite verbose, making the "
"configure stage quite noisy.  This cache option (``ON`` by default) hides "
"all population output unless an error is encountered.  If experiencing "
"problems with hung downloads, temporarily switching this option off may help "
"diagnose which content population is causing the issue."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:191
msgid "``FETCHCONTENT_FULLY_DISCONNECTED``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:185
msgid ""
"When this option is enabled, no attempt is made to download or update any "
"content.  It is assumed that all content has already been populated in a "
"previous run or the source directories have been pointed at existing "
"contents the developer has provided manually (using options described "
"further below).  When the developer knows that no changes have been made to "
"any content details, turning this option ``ON`` can significantly speed up "
"the configure stage.  It is ``OFF`` by default."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:200
msgid "``FETCHCONTENT_UPDATES_DISCONNECTED``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:194
msgid ""
"This is a less severe download/update control compared to "
"``FETCHCONTENT_FULLY_DISCONNECTED``.  Instead of bypassing all download and "
"update logic, the ``FETCHCONTENT_UPDATES_DISCONNECTED`` only disables the "
"update stage.  Therefore, if content has not been downloaded previously, it "
"will still be downloaded when this option is enabled.  This can speed up the "
"configure stage, but not as much as ``FETCHCONTENT_FULLY_DISCONNECTED``.  It "
"is ``OFF`` by default."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:202
msgid ""
"In addition to the above cache variables, the following cache variables are "
"also defined for each content name (``<ucName>`` is the uppercased value of "
"``<name>``):"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:216
msgid "``FETCHCONTENT_SOURCE_DIR_<ucName>``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:207
msgid ""
"If this is set, no download or update steps are performed for the specified "
"content and the ``<lcName>_SOURCE_DIR`` variable returned to the caller is "
"pointed at this location.  This gives developers a way to have a separate "
"checkout of the content that they can modify freely without interference "
"from the build.  The build simply uses that existing source, but it still "
"defines ``<lcName>_BINARY_DIR`` to point inside its own build area. "
"Developers are strongly encouraged to use this mechanism rather than editing "
"the sources populated in the default location, as changes to sources in the "
"default location can be lost when content population details are changed by "
"the project."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:225
msgid "``FETCHCONTENT_UPDATES_DISCONNECTED_<ucName>``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:219
msgid ""
"This is the per-content equivalent of ``FETCHCONTENT_UPDATES_DISCONNECTED``. "
"If the global option or this option is ``ON``, then updates will be disabled "
"for the named content. Disabling updates for individual content can be "
"useful for content whose details rarely change, while still leaving other "
"frequently changing content with updates enabled."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:227
msgid ""
"The ``FetchContent_Populate()`` command also supports a syntax allowing the "
"content details to be specified directly rather than using any saved "
"details.  This is more low-level and use of this form is generally to be "
"avoided in favour of using saved content details as outlined above. "
"Nevertheless, in certain situations it can be useful to invoke the content "
"population as an isolated operation (typically as part of implementing some "
"other higher level feature or when using CMake in script mode):"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:235
msgid ""
"FetchContent_Populate( <name>\n"
"  [QUIET]\n"
"  [SUBBUILD_DIR <subBuildDir>]\n"
"  [SOURCE_DIR <srcDir>]\n"
"  [BINARY_DIR <binDir>]\n"
"  ...\n"
")"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:245
msgid ""
"This form has a number of key differences to that where only ``<name>`` is "
"provided:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:248
msgid ""
"All required population details are assumed to have been provided directly "
"in the call to ``FetchContent_Populate()``. Any saved details for ``<name>`` "
"are ignored."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:251
msgid ""
"No check is made for whether content for ``<name>`` has already been "
"populated."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:253
msgid "No global property is set to record that the population has occurred."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:254
msgid ""
"No global properties record the source or binary directories used for the "
"populated content."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:256
msgid ""
"The ``FETCHCONTENT_FULLY_DISCONNECTED`` and "
"``FETCHCONTENT_UPDATES_DISCONNECTED`` cache variables are ignored."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:259
msgid ""
"The ``<lcName>_SOURCE_DIR`` and ``<lcName>_BINARY_DIR`` variables are still "
"returned to the caller, but since these locations are not stored as global "
"properties when this form is used, they are only available to the calling "
"scope and below rather than the entire project hierarchy.  No "
"``<lcName>_POPULATED`` variable is set in the caller's scope with this form."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:265
msgid ""
"The supported options for ``FetchContent_Populate()`` are the same as those "
"for :command:`FetchContent_Declare()`.  Those few options shown just above "
"are either specific to ``FetchContent_Populate()`` or their behavior is "
"slightly modified from how :command:`ExternalProject_Add` treats them."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:276
msgid "``QUIET``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:271
msgid ""
"The ``QUIET`` option can be given to hide the output associated with "
"populating the specified content.  If the population fails, the output will "
"be shown regardless of whether this option was given or not so that the "
"cause of the failure can be diagnosed.  The global ``FETCHCONTENT_QUIET`` "
"cache variable has no effect on ``FetchContent_Populate()`` calls where the "
"content details are provided directly."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:283
msgid "``SUBBUILD_DIR``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:279
msgid ""
"The ``SUBBUILD_DIR`` argument can be provided to change the location of the "
"sub-build created to perform the population.  The default value is "
"``${CMAKE_CURRENT_BINARY_DIR}/<lcName>-subbuild`` and it would be unusual to "
"need to override this default.  If a relative path is specified, it will be "
"interpreted as relative to :variable:`CMAKE_CURRENT_BINARY_DIR`."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:292
msgid "``SOURCE_DIR``, ``BINARY_DIR``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:286
msgid ""
"The ``SOURCE_DIR`` and ``BINARY_DIR`` arguments are supported by :command:"
"`ExternalProject_Add`, but different default values are used by "
"``FetchContent_Populate()``.  ``SOURCE_DIR`` defaults to "
"``${CMAKE_CURRENT_BINARY_DIR}/<lcName>-src`` and ``BINARY_DIR`` defaults to "
"``${CMAKE_CURRENT_BINARY_DIR}/<lcName>-build``.  If a relative path is "
"specified, it will be interpreted as relative to :variable:"
"`CMAKE_CURRENT_BINARY_DIR`."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:294
msgid ""
"In addition to the above explicit options, any other unrecognized options "
"are passed through unmodified to :command:`ExternalProject_Add` to perform "
"the download, patch and update steps.  The following options are explicitly "
"prohibited (they are disabled by the ``FetchContent_Populate()`` command):"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:299
msgid "``CONFIGURE_COMMAND``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:300
msgid "``BUILD_COMMAND``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:301
msgid "``INSTALL_COMMAND``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:302
msgid "``TEST_COMMAND``"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:304
msgid ""
"If using ``FetchContent_Populate()`` within CMake's script mode, be aware "
"that the implementation sets up a sub-build which therefore requires a CMake "
"generator and build tool to be available. If these cannot be found by "
"default, then the :variable:`CMAKE_GENERATOR` and/or :variable:"
"`CMAKE_MAKE_PROGRAM` variables will need to be set appropriately on the "
"command line invoking the script."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:313
msgid "Retrieve Population Properties"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:317
msgid ""
"When using saved content details, a call to :command:`FetchContent_Populate` "
"records information in global properties which can be queried at any time. "
"This information includes the source and binary directories associated with "
"the content and also whether or not the content population has been "
"processed during the current configure run."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:323
msgid ""
"FetchContent_GetProperties( <name>\n"
"  [SOURCE_DIR <srcDirVar>]\n"
"  [BINARY_DIR <binDirVar>]\n"
"  [POPULATED <doneVar>]\n"
")"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:331
msgid ""
"The ``SOURCE_DIR``, ``BINARY_DIR`` and ``POPULATED`` options can be used to "
"specify which properties should be retrieved.  Each option accepts a value "
"which is the name of the variable in which to store that property.  Most of "
"the time though, only ``<name>`` is given, in which case the call will then "
"set the same variables as a call to :command:`FetchContent_Populate(name) "
"<FetchContent_Populate>`.  This allows the following canonical pattern to be "
"used, which ensures that the relevant variables will always be defined "
"regardless of whether or not the population has been performed elsewhere in "
"the project already:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:341
msgid ""
"FetchContent_GetProperties(foobar)\n"
"if(NOT foobar_POPULATED)\n"
"  FetchContent_Populate(foobar)\n"
"\n"
"  # Set any custom variables, etc. here, then\n"
"  # populate the content as part of this build\n"
"\n"
"  add_subdirectory(${foobar_SOURCE_DIR} ${foobar_BINARY_DIR})\n"
"endif()"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:353
msgid ""
"The above pattern allows other parts of the overall project hierarchy to re-"
"use the same content and ensure that it is only populated once."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:360
msgid "Examples"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:362
msgid ""
"Consider a project hierarchy where ``projA`` is the top level project and it "
"depends on projects ``projB`` and ``projC``. Both ``projB`` and ``projC`` "
"can be built standalone and they also both depend on another project "
"``projD``.  For simplicity, this example will assume that all four projects "
"are available on a company git server.  The ``CMakeLists.txt`` of each "
"project might have sections like the following:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:369
msgid "*projA*:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:371
msgid ""
"include(FetchContent)\n"
"FetchContent_Declare(\n"
"  projB\n"
"  GIT_REPOSITORY git@mycompany.com/git/projB.git\n"
"  GIT_TAG        4a89dc7e24ff212a7b5167bef7ab079d\n"
")\n"
"FetchContent_Declare(\n"
"  projC\n"
"  GIT_REPOSITORY git@mycompany.com/git/projC.git\n"
"  GIT_TAG        4ad4016bd1d8d5412d135cf8ceea1bb9\n"
")\n"
"FetchContent_Declare(\n"
"  projD\n"
"  GIT_REPOSITORY git@mycompany.com/git/projD.git\n"
"  GIT_TAG        origin/integrationBranch\n"
")\n"
"\n"
"FetchContent_GetProperties(projB)\n"
"if(NOT projb_POPULATED)\n"
"  FetchContent_Populate(projB)\n"
"  add_subdirectory(${projb_SOURCE_DIR} ${projb_BINARY_DIR})\n"
"endif()\n"
"\n"
"FetchContent_GetProperties(projC)\n"
"if(NOT projc_POPULATED)\n"
"  FetchContent_Populate(projC)\n"
"  add_subdirectory(${projc_SOURCE_DIR} ${projc_BINARY_DIR})\n"
"endif()"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:402
msgid "*projB*:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:404
msgid ""
"include(FetchContent)\n"
"FetchContent_Declare(\n"
"  projD\n"
"  GIT_REPOSITORY git@mycompany.com/git/projD.git\n"
"  GIT_TAG        20b415f9034bbd2a2e8216e9a5c9e632\n"
")\n"
"\n"
"FetchContent_GetProperties(projD)\n"
"if(NOT projd_POPULATED)\n"
"  FetchContent_Populate(projD)\n"
"  add_subdirectory(${projd_SOURCE_DIR} ${projd_BINARY_DIR})\n"
"endif()"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:420
msgid "*projC*:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:422
msgid ""
"include(FetchContent)\n"
"FetchContent_Declare(\n"
"  projD\n"
"  GIT_REPOSITORY git@mycompany.com/git/projD.git\n"
"  GIT_TAG        7d9a17ad2c962aa13e2fbb8043fb6b8a\n"
")\n"
"\n"
"FetchContent_GetProperties(projD)\n"
"if(NOT projd_POPULATED)\n"
"  FetchContent_Populate(projD)\n"
"  add_subdirectory(${projd_SOURCE_DIR} ${projd_BINARY_DIR})\n"
"endif()"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:437
msgid "A few key points should be noted in the above:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:439
msgid ""
"``projB`` and ``projC`` define different content details for ``projD``, but "
"``projA`` also defines a set of content details for ``projD`` and because "
"``projA`` will define them first, the details from ``projB`` and ``projC`` "
"will not be used.  The override details defined by ``projA`` are not "
"required to match either of those from ``projB`` or ``projC``, but it is up "
"to the higher level project to ensure that the details it does define still "
"make sense for the child projects."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:446
msgid ""
"While ``projA`` defined content details for ``projD``, it did not need to "
"explicitly call ``FetchContent_Populate(projD)`` itself.  Instead, it leaves "
"that to a child project to do (in this case it will be ``projB`` since it is "
"added to the build ahead of ``projC``).  If ``projA`` needed to customize "
"how the ``projD`` content was brought into the build as well (e.g. define "
"some CMake variables before calling :command:`add_subdirectory` after "
"populating), it would do the call to ``FetchContent_Populate()``, etc. just "
"as it did for the ``projB`` and ``projC`` content.  For higher level "
"projects, it is usually enough to just define the override content details "
"and leave the actual population to the child projects.  This saves repeating "
"the same thing at each level of the project hierarchy unnecessarily."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:458
msgid ""
"Even though ``projA`` is the top level project in this example, it still "
"checks whether ``projB`` and ``projC`` have already been populated before "
"going ahead to do those populations.  This makes ``projA`` able to be more "
"easily incorporated as a child of some other higher level project in the "
"future if required.  Always protect a call to :command:"
"`FetchContent_Populate` with a check to :command:"
"`FetchContent_GetProperties`, even in what may be considered a top level "
"project at the time."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:468
msgid ""
"The following example demonstrates how one might download and unpack a "
"firmware tarball using CMake's :manual:`script mode <cmake(1)>`.  The call "
"to :command:`FetchContent_Populate` specifies all the content details and "
"the unpacked firmware will be placed in a ``firmware`` directory below the "
"current working directory."
msgstr ""

#: ../../../../Modules/FetchContent.cmake:474
msgid "*getFirmware.cmake*:"
msgstr ""

#: ../../../../Modules/FetchContent.cmake:476
msgid ""
"# NOTE: Intended to be run in script mode with cmake -P\n"
"include(FetchContent)\n"
"FetchContent_Populate(\n"
"  firmware\n"
"  URL        https://mycompany.com/assets/firmware-1.23-arm.tar.gz\n"
"  URL_HASH   MD5=68247684da89b608d466253762b0ff11\n"
"  SOURCE_DIR firmware\n"
")"
msgstr ""
